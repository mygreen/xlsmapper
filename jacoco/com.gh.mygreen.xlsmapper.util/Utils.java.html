<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.util</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;

import org.apache.poi.ss.usermodel.Sheet;

import com.gh.mygreen.xlsmapper.BeanFactory;
import com.gh.mygreen.xlsmapper.Configuration;
import com.gh.mygreen.xlsmapper.XlsMapperException;
import com.gh.mygreen.xlsmapper.annotation.XlsTrim;
import com.gh.mygreen.xlsmapper.cellconverter.DefaultElementConverter;
import com.gh.mygreen.xlsmapper.cellconverter.ElementConverter;
import com.gh.mygreen.xlsmapper.fieldprocessor.ProcessCase;
import com.gh.mygreen.xlsmapper.validation.SheetBindingErrors;


/**
 * ユーティリティクラス。
 *
 * @version 2.0
 * @author T.TSUCHIE
 * @author Naoki Takezoe
 * @author Mitsuyoshi Hasegawa
 *
 */
<span class="nc" id="L38">public class Utils {</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L41">    private static final ElementConverter ELEMENT_CONVERTER = new DefaultElementConverter();</span>

    /**
     * コレクションの要素を指定した区切り文字で繋げて1つの文字列とする。
     * @param col 処理対象のコレクション。
     * @param separator 区切り文字。
     * @param ignoreEmptyElement 空、nullの要素を無視するかどうか。
     * @param trim トリムをするかどうか。
     * @param elementConverter 要素を変換するクラス。
     * @return 結合した文字列
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public static String join(final Collection&lt;?&gt; col, final String separator,
            final boolean ignoreEmptyElement, final boolean trim, final ElementConverter elementConverter) {

<span class="fc" id="L56">        final List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">        for(Object element : col) {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            if(element == null) {</span>
<span class="fc" id="L59">                continue;</span>
            }

<span class="fc" id="L62">            Object value = element;</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">            if(element instanceof String) {</span>
<span class="fc" id="L65">                String str = (String) element;</span>
<span class="fc bfc" id="L66" title="All 4 branches covered.">                if(ignoreEmptyElement &amp;&amp; isEmpty(str)) {</span>
<span class="fc" id="L67">                    continue;</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">                } else if(trim) {</span>
<span class="fc" id="L70">                    value = str.trim();</span>
                }

<span class="pc bpc" id="L73" title="3 of 4 branches missed.">            } else if(element instanceof Character &amp;&amp; isEmpty(element.toString())) {</span>
<span class="nc" id="L74">                String str = element.toString();</span>
<span class="nc bnc" id="L75" title="All 4 branches missed.">                if(ignoreEmptyElement &amp;&amp; isEmpty(str)) {</span>
<span class="nc" id="L76">                    continue;</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">                } else if(trim) {</span>
<span class="nc" id="L79">                    value = str.trim().charAt(0);</span>
                }

<span class="pc bpc" id="L82" title="1 of 2 branches missed.">            } else if(char.class.isAssignableFrom(element.getClass())) {</span>
<span class="nc" id="L83">                String str = element.toString();</span>
<span class="nc bnc" id="L84" title="All 4 branches missed.">                if(ignoreEmptyElement &amp;&amp; isEmpty(str)) {</span>
<span class="nc" id="L85">                    continue;</span>

<span class="nc bnc" id="L87" title="All 2 branches missed.">                } else if(trim) {</span>
<span class="nc" id="L88">                    value = str.trim().charAt(0);</span>
                }
            }

<span class="fc" id="L92">            list.add(value);</span>

<span class="fc" id="L94">        }</span>

<span class="fc" id="L96">        return join(list, separator, elementConverter);</span>

    }

    /**
     * 配列の要素を指定した区切り文字で繋げて1つの文字列とする。
     * @param arrays 結合対象の配列
     * @param separator 区切り文字
     * @return 結合した文字列
     */
    public static String join(final Object[] arrays, final String separator) {

<span class="fc" id="L108">        return join(arrays, separator, ELEMENT_CONVERTER);</span>

    }

    /**
     * 配列の要素を指定した区切り文字で繋げて1つの文字列とする。
     * @param arrays 結合対象の配列
     * @param separator 区切り文字
     * @param elementConverter 要素を変換するクラス。
     * @return 結合した文字列
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static String join(final Object[] arrays, final String separator, final ElementConverter elementConverter) {

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if(arrays == null) {</span>
<span class="nc" id="L123">            return &quot;&quot;;</span>
        }

<span class="fc" id="L126">        final int len = arrays.length;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if(len == 0) {</span>
<span class="nc" id="L128">            return &quot;&quot;;</span>
        }

<span class="fc" id="L131">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for(int i=0; i &lt; len; i++) {</span>
<span class="fc" id="L133">            final Object element = arrays[i];</span>
<span class="fc" id="L134">            sb.append(elementConverter.convertToString(element));</span>

<span class="pc bpc" id="L136" title="1 of 4 branches missed.">            if(separator != null &amp;&amp; (i &lt; len-1)) {</span>
<span class="fc" id="L137">                sb.append(separator);</span>
            }
        }

<span class="fc" id="L141">        return sb.toString();</span>

    }

    /**
     * Collectionの要素を指定した区切り文字で繋げて1つの文字列とする。
     * @param col 結合対象のコレクション
     * @param separator 区切り文字
     * @return 結合した文字列
     */
    public static String join(final Collection&lt;?&gt; col, final String separator) {
<span class="fc" id="L152">        return join(col, separator, ELEMENT_CONVERTER);</span>
    }

    /**
     * Collectionの要素を指定した区切り文字で繋げて1つの文字列とする。
     * @param col 結合対象のコレクション
     * @param separator 区切り文字
     * @param elementConverter 要素を変換するクラス。
     * @return 結合した文字列
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static String join(final Collection&lt;?&gt; col, final String separator, final ElementConverter elementConverter) {

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if(col == null) {</span>
<span class="nc" id="L166">            return &quot;&quot;;</span>
        }

<span class="fc" id="L169">        final int size = col.size();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if(size == 0) {</span>
<span class="fc" id="L171">            return &quot;&quot;;</span>
        }

<span class="fc" id="L174">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        for(Iterator&lt;?&gt; itr = col.iterator(); itr.hasNext();) {</span>
<span class="fc" id="L176">            final Object element = itr.next();</span>
<span class="fc" id="L177">            String text = elementConverter.convertToString(element);</span>
<span class="fc" id="L178">            sb.append(text);</span>

<span class="pc bpc" id="L180" title="1 of 4 branches missed.">            if(separator != null &amp;&amp; itr.hasNext()) {</span>
<span class="fc" id="L181">                sb.append(separator);</span>
            }
<span class="fc" id="L183">        }</span>

<span class="fc" id="L185">        return sb.toString();</span>

    }

    /**
     * 先頭の文字を大文字にする。
     * &lt;pre&gt;
     * Utils.capitalize(null)  = null
     * Utils.capitalize(&quot;&quot;)    = &quot;&quot;
     * Utils.capitalize(&quot;cat&quot;) = &quot;Cat&quot;
     * Utils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;
     * &lt;/pre&gt;
     * @param str
     * @return 引数がnull、空文字の場合、そのまま返す。
     */
    public static String capitalize(final String str) {
        final int strLen;
<span class="fc bfc" id="L202" title="All 4 branches covered.">        if(str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L203">            return str;</span>
        }

<span class="fc" id="L206">        return new StringBuilder(strLen)</span>
<span class="fc" id="L207">            .append(String.valueOf(str.charAt(0)).toUpperCase())</span>
<span class="fc" id="L208">            .append(str.substring(1))</span>
<span class="fc" id="L209">            .toString();</span>
    }

    /**
     * 先頭の文字を小文字にする。
     * @param str 変換対象の文字
     * @return 引数がnull、空文字の場合、そのまま返す。
     */
    public static String uncapitalize(final String str) {
        final int strLen;
<span class="fc bfc" id="L219" title="All 4 branches covered.">        if(str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L220">            return str;</span>
        }

<span class="fc" id="L223">        return new StringBuilder(strLen)</span>
<span class="fc" id="L224">            .append(String.valueOf(str.charAt(0)).toLowerCase())</span>
<span class="fc" id="L225">            .append(str.substring(1))</span>
<span class="fc" id="L226">            .toString();</span>
    }

    /**
     * システム設定に従いラベルを比較する。
     * &lt;p&gt;正規表現や正規化を行い指定する。
     *
     * @since 1.1
     * @param text1 セルのラベル
     * @param text2 アノテーションに指定されているラベル。
     *              {@literal /&lt;ラベル&gt;/}と指定する場合、正規表現による比較を行う。
     * @param config システム設定
     * @return true:ラベルが一致する。比較対象のラベルがnullの場合は、falseを返す。
     */
    public static boolean matches(final String text1, final String text2, final Configuration config){
        
<span class="pc bpc" id="L242" title="2 of 4 branches missed.">        if(text1 == null || text2 == null) {</span>
<span class="nc" id="L243">            return false;</span>
        }
        
<span class="pc bpc" id="L246" title="1 of 6 branches missed.">        if(config.isRegexLabelText() &amp;&amp; text2.startsWith(&quot;/&quot;) &amp;&amp; text2.endsWith(&quot;/&quot;)){</span>
<span class="fc" id="L247">            return normalize(text1, config).matches(text2.substring(1, text2.length() - 1));</span>
        } else {
<span class="fc" id="L249">            return normalize(text1, config).equals(normalize(text2, config));</span>
//            return normalize(text1, config).equals(text2);
        }
    }

    /**
     * システム設定に従いラベルを正規化する。
     * @since 1.1
     * @param text セルのラベル
     * @param config システム設定
     * @return true:ラベルが一致する。
     */
    public static String normalize(final String text, final Configuration config){
<span class="pc bpc" id="L262" title="1 of 4 branches missed.">        if(text != null &amp;&amp; config.isNormalizeLabelText()){</span>
<span class="fc" id="L263">            return text.trim().replaceAll(&quot;[\n\r]&quot;, &quot;&quot;).replaceAll(&quot;[\t 　]+&quot;, &quot; &quot;);</span>
        }
<span class="fc" id="L265">        return text;</span>
    }

    /**
     * 文字列が空文字か判定する。
     * &lt;p&gt;文字数が1でかつ、{@literal \u0000}のときは、trueを判定する。&lt;/p&gt;
     * @param str 判定対象の文字
     * @return trueの場合、空文字を判定する。
     */
    public static boolean isEmpty(final String str) {
<span class="fc bfc" id="L275" title="All 4 branches covered.">        if(str == null || str.isEmpty()) {</span>
<span class="fc" id="L276">            return true;</span>
        }

<span class="fc bfc" id="L279" title="All 2 branches covered.">        if(str.length() == 1) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            return str.charAt(0) == '\u0000';</span>
        }

<span class="fc" id="L283">        return false;</span>
    }

    /**
     * 文字列が空文字でないか判定する。
     * @param str 判定対象の文字
     * @return
     */
    public static boolean isNotEmpty(final String str) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        return !isEmpty(str);</span>
    }

    /**
     * コレクションが空か判定する。
     * @param collection
     * @return nullまたはサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L301" title="All 4 branches missed.">        if(collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L302">            return true;</span>
        }

<span class="nc" id="L305">        return false;</span>
    }

    public static boolean isNotEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        return !isEmpty(collection);</span>
    }

    /**
     * 配列がが空か判定する。
     * @param arrays
     * @return nullまたは、配列のサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Object[] arrays) {
<span class="nc bnc" id="L318" title="All 4 branches missed.">        if(arrays == null || arrays.length == 0) {</span>
<span class="nc" id="L319">            return true;</span>
        }

<span class="nc" id="L322">        return false;</span>
    }

    /**
     * 配列が空でないか判定する
     * @param arrays
     * @return
     */
    public static boolean isNotEmpty(final Object[] arrays) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        return !isEmpty(arrays);</span>
    }

    /**
     * オブジェクトの比較を行う。
     * &lt;p&gt;値がnullの場合を考慮する。
     * @param obj1
     * @param obj2
     * @return
     */
    public static boolean equals(final Object obj1, final Object obj2) {

<span class="pc bpc" id="L343" title="3 of 4 branches missed.">        if(obj1 == null &amp;&amp; obj2 == null) {</span>
<span class="nc" id="L344">            return true;</span>
        }

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if(obj1 == null) {</span>
<span class="nc" id="L348">            return false;</span>
        }

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if(obj2 == null) {</span>
<span class="nc" id="L352">            return false;</span>
        }

<span class="fc" id="L355">        return obj1.equals(obj2);</span>

    }

    public static boolean notEquals(final Object obj1, final Object obj2) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        return !equals(obj1, obj2);</span>
    }

    /**
     * オブジェクトを文字列に変換する。
     * &lt;p&gt;nullの場合、文字列として &quot;null&quot;を返す。
     * &lt;p&gt;単純に、{@link Object#toString()}を呼び出す。
     * @param value
     * @return
     */
    public static String convertToString(final Object value) {

<span class="nc bnc" id="L372" title="All 2 branches missed.">        if(value == null) {</span>
<span class="nc" id="L373">            return &quot;null&quot;;</span>
        }

<span class="nc" id="L376">        return value.toString();</span>

    }

    /**
     * アノテーションの属性trimに従い、文字列をトリムする。
     * @param value トリム対象の文字
     * @param trimAnno トリムのアノテーション
     * @return トリミングした結果。
     */
    public static String trim(final String value, final Optional&lt;XlsTrim&gt; trimAnno) {

<span class="pc bpc" id="L388" title="1 of 4 branches missed.">        if(!trimAnno.isPresent() || value == null) {</span>
<span class="fc" id="L389">            return value;</span>
        }

<span class="fc" id="L392">        return value.trim();</span>

    }

    /**
     * 文字列をトリムする。
     * @param value トリム対象の文字
     * @param trimmed トリムするかどうか。
     * @return トリミングした結果。
     */
    public static String trim(final String value, final boolean trimmed) {
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">        if(!trimmed || value == null) {</span>
<span class="fc" id="L404">            return value;</span>
        }

<span class="fc" id="L407">        return value.trim();</span>

    }

    /**
     * PostProcessなどのメソッドを実行する。
     * &lt;p&gt;メソッドの引数が既知のものであれば、インスタンスを設定する。
     *
     * @param processObj 実行対象の処理が埋め込まれているオブジェクト。
     * @param method 実行対象のメソッド情報
     * @param beanObj 処理対象のBeanオブジェクト。
     * @param sheet シート情報
     * @param config 共通設定
     * @param errors エラー情報
     * @param processCase 処理ケース
     * @throws XlsMapperException
     */
    public static void invokeNeedProcessMethod(final Object processObj, final Method method, final Object beanObj,
            final Sheet sheet, final Configuration config, final SheetBindingErrors&lt;?&gt; errors, final ProcessCase processCase)
                    throws XlsMapperException {

<span class="fc" id="L428">        final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span>
<span class="fc" id="L429">        final Object[] paramValues =  new Object[paramTypes.length];</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">        for(int i=0; i &lt; paramTypes.length; i++) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">            if(Sheet.class.isAssignableFrom(paramTypes[i])) {</span>
<span class="fc" id="L433">                paramValues[i] = sheet;</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">            } else if(Configuration.class.isAssignableFrom(paramTypes[i])) {</span>
<span class="fc" id="L436">                paramValues[i] = config;</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">            } else if(SheetBindingErrors.class.isAssignableFrom(paramTypes[i])) {</span>
<span class="fc" id="L439">                paramValues[i] = errors;</span>

<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            } else if(paramTypes[i].isAssignableFrom(beanObj.getClass())) {</span>
<span class="fc" id="L442">                paramValues[i] = beanObj;</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">            } else if(ProcessCase.class.equals(paramTypes[i])) {</span>
<span class="nc" id="L445">                paramValues[i] = processCase;</span>

<span class="nc bnc" id="L447" title="All 2 branches missed.">            } else if(paramTypes[i].equals(Object.class)) {</span>
<span class="nc" id="L448">                paramValues[i] = beanObj;</span>

            } else {
<span class="nc" id="L451">                paramValues[i] = null;</span>
            }
        }

        try {
<span class="fc" id="L456">            method.setAccessible(true);</span>
<span class="fc" id="L457">            method.invoke(processObj, paramValues);</span>
<span class="nc" id="L458">        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            Throwable t = e.getCause() == null ? e : e.getCause();</span>
<span class="nc" id="L460">            throw new XlsMapperException(</span>
<span class="nc" id="L461">                    String.format(&quot;fail execute method '%s#%s'.&quot;, processObj.getClass().getName(), method.getName()),</span>
                    t);
<span class="fc" id="L463">        }</span>
<span class="fc" id="L464">    }</span>

    /**
     * 文字列形式のロケールをオブジェクトに変換する。
     * &lt;p&gt;アンダーバーで区切った'ja_JP'を分解して、Localeに渡す。
     * @param str
     * @return 引数が空の時はデフォルトロケールを返す。
     */
    public static Locale getLocale(final String str) {

<span class="fc bfc" id="L474" title="All 2 branches covered.">        if(isEmpty(str)) {</span>
<span class="fc" id="L475">            return Locale.getDefault();</span>
        }

<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if(!str.contains(&quot;_&quot;)) {</span>
<span class="nc" id="L479">            return new Locale(str);</span>
        }

<span class="fc" id="L482">        final String[] split = str.split(&quot;_&quot;);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">        if(split.length == 2) {</span>
<span class="fc" id="L484">            return new Locale(split[0], split[1]);</span>

        } else {
<span class="nc" id="L487">            return new Locale(split[0], split[1], split[2]);</span>
        }

    }

    /**
     * エスケープ文字を除去した文字列を取得する。
     * @param str
     * @param escapeChar
     * @return
     */
    public static String removeEscapeChar(final String str, final char escapeChar) {

<span class="pc bpc" id="L500" title="2 of 4 branches missed.">        if(str == null || str.isEmpty()) {</span>
<span class="nc" id="L501">            return str;</span>
        }

<span class="fc" id="L504">        final String escapeStr = String.valueOf(escapeChar);</span>
<span class="fc" id="L505">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L507">        LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;();</span>

<span class="fc" id="L509">        final int length = str.length();</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">        for(int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L511">            final char c = str.charAt(i);</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">            if(StackUtils.equalsTopElement(stack, escapeStr)) {</span>
                // スタックの一番上がエスケープ文字の場合
<span class="fc" id="L515">                StackUtils.popup(stack);</span>
<span class="fc" id="L516">                sb.append(c);</span>

<span class="fc bfc" id="L518" title="All 2 branches covered.">            } else if(c == escapeChar) {</span>
                // スタックに積む
<span class="fc" id="L520">                stack.push(String.valueOf(c));</span>

            } else {
<span class="fc" id="L523">                sb.append(c);</span>
            }

        }

<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if(!stack.isEmpty()) {</span>
<span class="nc" id="L529">            sb.append(StackUtils.popupAndConcat(stack));</span>
        }

<span class="fc" id="L532">        return sb.toString();</span>

    }

    /**
     * Listのインスタンスを他のCollectionのインスタンスに変換する。
     * &lt;p&gt;ただし、変換先のクラスタイプがインタフェースの場合は変換しない。
     * &lt;p&gt;変換元のクラスと変換先のクラスが同じ場合は、変換しない。
     *
     * @since 1.0
     * @param list 変換元のListのインスタンス
     * @param toClass 変換先のCollectionのクラス
     * @param beanFactory てインスタンスを生成するファクトリクラス。
     * @return 変換したコレクションのインスタンス
     */
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public static Collection convertListToCollection(final List list, final Class&lt;Collection&gt; toClass,
            final BeanFactory&lt;Class&lt;?&gt;, Object&gt; beanFactory) {

<span class="fc bfc" id="L551" title="All 2 branches covered.">        if(list.getClass().equals(toClass)) {</span>
<span class="fc" id="L552">            return list;</span>
        }

<span class="fc bfc" id="L555" title="All 2 branches covered.">        if(toClass.isInterface()) {</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if(List.class.isAssignableFrom(toClass)) {</span>
                // 変換先がListの実態の場合はそのまま。
<span class="fc" id="L558">                return list;</span>

<span class="fc bfc" id="L560" title="All 2 branches covered.">            } else if(Set.class.isAssignableFrom(toClass)) {</span>

<span class="fc" id="L562">                Collection value = (Collection) beanFactory.create(LinkedHashSet.class);</span>
<span class="fc" id="L563">                value.addAll(list);</span>
<span class="fc" id="L564">                return value;</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">            } else if(Queue.class.isAssignableFrom(toClass)) {</span>

<span class="fc" id="L568">                Collection value = (Collection) beanFactory.create(LinkedList.class);</span>
<span class="fc" id="L569">                value.addAll(list);</span>
<span class="fc" id="L570">                return value;</span>

<span class="pc bpc" id="L572" title="1 of 2 branches missed.">            } else if(Collection.class.isAssignableFrom(toClass)) {</span>
<span class="fc" id="L573">                Collection value = (Collection) beanFactory.create(ArrayList.class);</span>
<span class="fc" id="L574">                value.addAll(list);</span>
<span class="fc" id="L575">                return value;</span>

            } else {
<span class="nc" id="L578">                throw new IllegalArgumentException(&quot;not support class type:&quot; + toClass.getName());</span>
            }

        }

<span class="fc" id="L583">        Collection value = (Collection) beanFactory.create(toClass);</span>
<span class="fc" id="L584">        value.addAll(list);</span>

<span class="fc" id="L586">        return value;</span>

    }

    /**
     * CollectionのインスタンスをListに変換する。
     *
     * @since 1.0
     * @param collection 変換元のCollectionのインスタンス。
     * @return 変換したListのインスタンス。
     */
    public static &lt;T&gt; List&lt;T&gt; convertCollectionToList(final Collection&lt;T&gt; collection) {

<span class="fc bfc" id="L599" title="All 2 branches covered.">        if(List.class.isAssignableFrom(collection.getClass())) {</span>
<span class="fc" id="L600">            return (List&lt;T&gt;)collection;</span>
        }

<span class="fc" id="L603">        return new ArrayList&lt;&gt;(collection);</span>

    }

    /**
     * リストに要素のインデックスを指定して追加します。
     * &lt;p&gt;リストのサイズが足りない場合は、サイズを自動的に変更します。&lt;/p&gt;
     * @since 2.0
     * @param list リスト
     * @param element 追加する要素。値はnullでもよい。
     * @param index 追加する要素のインデックス番号(0以上)
     * @throws IllegalArgumentException {@literal list == null.}
     * @throws IllegalArgumentException {@literal index &lt; 0.}
     */
    public static &lt;P&gt; void addListWithIndex(final List&lt;P&gt; list, final P element, final int index) {
<span class="fc" id="L618">        ArgUtils.notNull(list, &quot;list&quot;);</span>
<span class="fc" id="L619">        ArgUtils.notMin(index, 0, &quot;index&quot;);</span>

<span class="fc" id="L621">        final int listSize = list.size();</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if(listSize &lt; index) {</span>
            // 足りない場合は、要素を追加する。
<span class="fc" id="L624">            final int lackSize = index - listSize;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            for(int i=0; i &lt; lackSize; i++) {</span>
<span class="fc" id="L626">                list.add(null);</span>
            }
<span class="fc" id="L628">            list.add(element);</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">        } else if(listSize == index) {</span>
            // 最後の要素に追加する
<span class="fc" id="L632">            list.add(element);</span>

        } else {
            // リストのサイズが足りている場合
<span class="fc" id="L636">            list.set(index, element);</span>
        }

<span class="fc" id="L639">    }</span>

    /**
     * プリミティブ型のデフォルト値を取得します。
     * @param type 変換対象のクラスタイプ。
     * @return 対応していない型の場合は、nullを返します。
     * @throws IllegalArgumentException {@literal type is null.}
     */
    public static Object getPrimitiveDefaultValue(final Class&lt;?&gt; type) {
<span class="fc" id="L648">        ArgUtils.notNull(type, &quot;type&quot;);</span>

<span class="fc bfc" id="L650" title="All 2 branches covered.">        if(!type.isPrimitive()) {</span>
<span class="fc" id="L651">            return null;</span>
        }

<span class="fc bfc" id="L654" title="All 2 branches covered.">        if(type.equals(boolean.class)) {</span>
<span class="fc" id="L655">            return false;</span>

<span class="fc bfc" id="L657" title="All 2 branches covered.">        } else if(type.equals(char.class)) {</span>
<span class="fc" id="L658">            return '\u0000';</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">        } else if(type.equals(byte.class)) {</span>
<span class="fc" id="L661">            return (byte)0;</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">        } else if(type.equals(short.class)) {</span>
<span class="fc" id="L664">            return (short)0;</span>

<span class="fc bfc" id="L666" title="All 2 branches covered.">        } else if(type.equals(int.class)) {</span>
<span class="fc" id="L667">            return 0;</span>

<span class="fc bfc" id="L669" title="All 2 branches covered.">        } else if(type.equals(long.class)) {</span>
<span class="fc" id="L670">            return 0l;</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">        } else if(type.equals(float.class)) {</span>
<span class="fc" id="L673">            return 0.0f;</span>

<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        } else if(type.equals(double.class)) {</span>
<span class="fc" id="L676">            return 0.0d;</span>

        }

<span class="nc" id="L680">        return null;</span>
    }

    /**
     * 配列を{@link List}に変換します。
     * プリミティブ型の配列をを考慮して処理します。
     * @param object 変換対象の配列
     * @param componentType 配列の要素のタイプ
     * @return 配列がnullの場合は、空のリストに変換します。
     * @throws IllegalArgumentException {@literal arrayが配列でない場合。componentTypeがサポートしていないプリミティブ型の場合。}
     */
    public static List&lt;Object&gt; asList(final Object object, final Class&lt;?&gt; componentType) {
<span class="fc" id="L692">        ArgUtils.notNull(componentType, &quot;componentType&quot;);</span>

<span class="fc bfc" id="L694" title="All 2 branches covered.">        if(object == null) {</span>
<span class="fc" id="L695">            return new ArrayList&lt;&gt;();</span>
        }

<span class="fc bfc" id="L698" title="All 2 branches covered.">        if(!object.getClass().isArray()) {</span>
<span class="fc" id="L699">            throw new IllegalArgumentException(String.format(&quot;args0 is not arrays : %s.&quot;, object.getClass().getName()));</span>
        }

<span class="fc bfc" id="L702" title="All 2 branches covered.">        if(!componentType.isPrimitive()) {</span>
<span class="fc" id="L703">            return Arrays.asList((Object[])object);</span>
        }

<span class="fc bfc" id="L706" title="All 2 branches covered.">        if(componentType.equals(boolean.class)) {</span>
<span class="fc" id="L707">            boolean[] array = (boolean[])object;</span>
<span class="fc" id="L708">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            for(boolean v : array) {</span>
<span class="fc" id="L710">                list.add(v);</span>
            }
<span class="fc" id="L712">            return list;</span>

<span class="fc bfc" id="L714" title="All 2 branches covered.">        } else if(componentType.equals(char.class)) {</span>
<span class="fc" id="L715">            char[] array = (char[])object;</span>
<span class="fc" id="L716">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            for(char v : array) {</span>
<span class="fc" id="L718">                list.add(v);</span>
            }
<span class="fc" id="L720">            return list;</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">        } else if(componentType.equals(byte.class)) {</span>
<span class="fc" id="L723">            byte[] array = (byte[])object;</span>
<span class="fc" id="L724">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for(byte v : array) {</span>
<span class="fc" id="L726">                list.add(v);</span>
            }
<span class="fc" id="L728">            return list;</span>

<span class="fc bfc" id="L730" title="All 2 branches covered.">        } else if(componentType.equals(short.class)) {</span>
<span class="fc" id="L731">            short[] array = (short[])object;</span>
<span class="fc" id="L732">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">            for(short v : array) {</span>
<span class="fc" id="L734">                list.add(v);</span>
            }
<span class="fc" id="L736">            return list;</span>

<span class="fc bfc" id="L738" title="All 2 branches covered.">        } else if(componentType.equals(int.class)) {</span>
<span class="fc" id="L739">            int[] array = (int[])object;</span>
<span class="fc" id="L740">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">            for(int v : array) {</span>
<span class="fc" id="L742">                list.add(v);</span>
            }
<span class="fc" id="L744">            return list;</span>

<span class="fc bfc" id="L746" title="All 2 branches covered.">        } else if(componentType.equals(long.class)) {</span>
<span class="fc" id="L747">            long[] array = (long[])object;</span>
<span class="fc" id="L748">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">            for(long v : array) {</span>
<span class="fc" id="L750">                list.add(v);</span>
            }
<span class="fc" id="L752">            return list;</span>

<span class="fc bfc" id="L754" title="All 2 branches covered.">        } else if(componentType.equals(float.class)) {</span>
<span class="fc" id="L755">            float[] array = (float[])object;</span>
<span class="fc" id="L756">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">            for(float v : array) {</span>
<span class="fc" id="L758">                list.add(v);</span>
            }
<span class="fc" id="L760">            return list;</span>

<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        } else if(componentType.equals(double.class)) {</span>
<span class="fc" id="L763">            double[] array = (double[])object;</span>
<span class="fc" id="L764">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(array.length);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">            for(double v : array) {</span>
<span class="fc" id="L766">                list.add(v);</span>
            }
<span class="fc" id="L768">            return list;</span>

        }

<span class="nc" id="L772">        throw new IllegalArgumentException(String.format(&quot;not support primitive type : %s.&quot;, componentType.getName()));</span>

    }

    /**
     * コレクションを配列に変換する。
     * @param collection 変換対象のコレクション。
     * @return 変換した配列。
     * @throws IllegalArgumentException {@literal collection is null.}
     */
    public static int[] toArray(final Collection&lt;Integer&gt; collection) {
<span class="fc" id="L783">        ArgUtils.notNull(collection, &quot;collection&quot;);</span>

<span class="fc" id="L785">        final int size = collection.size();</span>
<span class="fc" id="L786">        final int[] array = new int[size];</span>

<span class="fc" id="L788">        int i=0;</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        for(Integer value : collection) {</span>
<span class="fc" id="L790">            array[i] = value;</span>
<span class="fc" id="L791">            i++;</span>
<span class="fc" id="L792">        }</span>

<span class="fc" id="L794">        return array;</span>
    }

    /**
     * 配列のサイズを取得します。
     * プリミティブ型の配列をを考慮して処理します。
     * @param object 取得対象の配列
     * @param componentType 配列の要素のタイプ
     * @return 配列がnullの場合は、0を返します。
     * @throws IllegalArgumentException {@literal arrayが配列でない場合。componentTypeがサポートしていないプリミティブ型の場合。}
     */
    public static int getArraySize(final Object object, final Class&lt;?&gt; componentType) {

<span class="fc" id="L807">        ArgUtils.notNull(componentType, &quot;componentType&quot;);</span>

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        if(object == null) {</span>
<span class="nc" id="L810">            return 0;</span>
        }

<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if(!object.getClass().isArray()) {</span>
<span class="nc" id="L814">            throw new IllegalArgumentException(String.format(&quot;args0 is not arrays : %s.&quot;, object.getClass().getName()));</span>
        }

<span class="fc bfc" id="L817" title="All 2 branches covered.">        if(!componentType.isPrimitive()) {</span>
<span class="fc" id="L818">            return ((Object[])object).length;</span>
        }

<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if(componentType.equals(boolean.class)) {</span>
<span class="nc" id="L822">            return ((boolean[]) object).length;</span>

<span class="pc bpc" id="L824" title="1 of 2 branches missed.">        } else if(componentType.equals(char.class)) {</span>
<span class="nc" id="L825">            return ((char[]) object).length;</span>

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        } else if(componentType.equals(byte.class)) {</span>
<span class="nc" id="L828">            return ((byte[]) object).length;</span>

<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        } else if(componentType.equals(short.class)) {</span>
<span class="nc" id="L831">            return ((short[]) object).length;</span>

<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        } else if(componentType.equals(int.class)) {</span>
<span class="fc" id="L834">            return ((int[]) object).length;</span>

<span class="nc bnc" id="L836" title="All 2 branches missed.">        } else if(componentType.equals(long.class)) {</span>
<span class="nc" id="L837">            return ((long[]) object).length;</span>

<span class="nc bnc" id="L839" title="All 2 branches missed.">        } else if(componentType.equals(float.class)) {</span>
<span class="nc" id="L840">            return ((byte[]) object).length;</span>

<span class="nc bnc" id="L842" title="All 2 branches missed.">        } else if(componentType.equals(double.class)) {</span>
<span class="nc" id="L843">            return ((byte[]) object).length;</span>

        }

<span class="nc" id="L847">        throw new IllegalArgumentException(String.format(&quot;not support primitive type : %s.&quot;, componentType.getName()));</span>
    }

    /**
     * 文字列配列の結合
     * @param array1
     * @param array2
     * @return 結合した配列。引数のどちらからnullの場合は、cloneした配列を返します。
     */
    public static String[] concat(final String[] array1, final String[] array2) {

<span class="pc bpc" id="L858" title="1 of 4 branches missed.">        if(array1 == null || array1.length == 0) {</span>
<span class="fc" id="L859">            return clone(array2);</span>

<span class="pc bpc" id="L861" title="2 of 4 branches missed.">        } else if(array2 == null || array2.length == 0) {</span>
<span class="nc" id="L862">            return clone(array1);</span>
        }

<span class="fc" id="L865">        final String[] joinedArray = new String[array1.length + array2.length];</span>
<span class="fc" id="L866">        System.arraycopy(array1, 0, joinedArray, 0, array1.length);</span>
<span class="fc" id="L867">        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);</span>
<span class="fc" id="L868">        return joinedArray;</span>

    }

    /**
     * 文字列の配列をクローンします。
     * @param array クローン対象の配列
     * @return クローンした配列。引数がnullの場合は、nullを返します。
     */
    public static String[] clone(final String[] array) {
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L879">            return null;</span>
        }
<span class="fc" id="L881">        return array.clone();</span>
    }

    /**
     * 読み込み処理のケースか判定する。
     * &lt;p&gt;ケースが指定されていないときは、該当すると判定する。&lt;/p&gt;
     * @since 2.0
     * @param cases 判定対象のケース
     * @return trueのとき、読み込み対象と判定する。
     */
    public static boolean isLoadCase(final ProcessCase[] cases) {

<span class="pc bpc" id="L893" title="1 of 4 branches missed.">        if(cases == null || cases.length == 0) {</span>
<span class="fc" id="L894">            return true;</span>
        }

<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        for(ProcessCase pc : cases) {</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">            if(pc == ProcessCase.Load) {</span>
<span class="fc" id="L899">                return true;</span>
            }
        }

<span class="nc" id="L903">        return false;</span>

    }

    /**
     * 書き込み処理のケースか判定する。
     * &lt;p&gt;ケースが指定されていないときは、該当すると判定する。&lt;/p&gt;
     * @since 2.0
     * @param cases 判定対象のケース
     * @return trueのとき、書き込み対象と判定する。
     */
    public static boolean isSaveCase(final ProcessCase[] cases) {

<span class="pc bpc" id="L916" title="1 of 4 branches missed.">        if(cases == null || cases.length == 0) {</span>
<span class="fc" id="L917">            return true;</span>
        }

<span class="fc bfc" id="L920" title="All 2 branches covered.">        for(ProcessCase pc : cases) {</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if(pc == ProcessCase.Save) {</span>
<span class="nc" id="L922">                return true;</span>
            }
        }

<span class="fc" id="L926">        return false;</span>

    }

    /**
     * 現在の処理ケースが該当するか判定する。
     * &lt;p&gt;ケースが指定されていないときは、該当すると判定する。&lt;/p&gt;
     * @param currentCase 現在の処理ケース
     * @param cases 判定対象のケース
     * @return trueのとき判定対象。
     * @throws IllegalArgumentException {@code currentCase is null.}
     */
    public static boolean isProcessCase(final ProcessCase currentCase, ProcessCase[] cases) {

<span class="fc" id="L940">        ArgUtils.notNull(currentCase, &quot;currentCase&quot;);</span>

<span class="fc bfc" id="L942" title="All 2 branches covered.">        if(currentCase == ProcessCase.Load) {</span>
<span class="fc" id="L943">            return isLoadCase(cases);</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        } else if(currentCase == ProcessCase.Save) {</span>
<span class="fc" id="L945">            return isSaveCase(cases);</span>
        } else {
<span class="nc" id="L947">            throw new IllegalArgumentException(&quot;currentCase is not support:&quot; + currentCase);</span>
        }

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>