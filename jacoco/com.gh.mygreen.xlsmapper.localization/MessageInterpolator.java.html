<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageInterpolator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.localization</a> &gt; <span class="el_source">MessageInterpolator.java</span></div><h1>MessageInterpolator.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.localization;

import java.util.Formatter;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.gh.mygreen.xlsmapper.expression.CustomFunctions;
import com.gh.mygreen.xlsmapper.expression.ExpressionEvaluationException;
import com.gh.mygreen.xlsmapper.expression.ExpressionLanguage;
import com.gh.mygreen.xlsmapper.expression.ExpressionLanguageJEXLImpl;
import com.gh.mygreen.xlsmapper.util.ArgUtils;
import com.gh.mygreen.xlsmapper.util.StackUtils;
import com.gh.mygreen.xlsmapper.util.Utils;


/**
 * 名前付き変数のメッセージをフォーマットするクラス。
 * &lt;p&gt;&lt;code&gt;{...}&lt;/code&gt;の場合、変数を単純に置換する。&lt;/p&gt;
 * &lt;p&gt;&lt;code&gt;${...}&lt;/code&gt;の場合、EL式を利用し処理する。&lt;/p&gt;
 * &lt;p&gt;文字'$', '{', '}'は特殊文字のため、&lt;code&gt;\&lt;/code&gt;でエスケープを行う。&lt;/p&gt;
 * &lt;p&gt;ELのパーサは、{@link ExpressionLanguage}の実装クラスで切り替え可能。&lt;/p&gt;
 * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数&lt;code&gt;{...}&lt;/code&gt;をメッセージ定義コードとして解決する。
 *   &lt;br&gt;ただし、メッセージ変数で指定されている変数が優先される。
 * &lt;/p&gt;
 * 
 * @version 2.0
 * @author T.TSUCHIE
 *
 */
public class MessageInterpolator {
    
<span class="fc" id="L38">    private static final Logger logger = LoggerFactory.getLogger(MessageInterpolator.class);</span>
    
    private ExpressionLanguage expressionLanguage;
    
<span class="fc" id="L42">    public MessageInterpolator() {</span>
        
        // EL式中で使用可能な関数の登録
<span class="fc" id="L45">        ExpressionLanguageJEXLImpl el = new ExpressionLanguageJEXLImpl();</span>
        
<span class="fc" id="L47">        Map&lt;String, Object&gt; funcs = new HashMap&lt;&gt;(); </span>
<span class="fc" id="L48">        funcs.put(&quot;f&quot;, CustomFunctions.class);</span>
<span class="fc" id="L49">        el.getJexlEngine().setFunctions(funcs);</span>
        
<span class="fc" id="L51">        setExpressionLanguage(el);</span>
        
<span class="fc" id="L53">    }</span>
    
    /**
     * 式言語の実装を指定するコンストラクタ
     * @param expressionLanguage
     */
<span class="fc" id="L59">    public MessageInterpolator(final ExpressionLanguage expressionLanguage) {</span>
<span class="fc" id="L60">        ArgUtils.notNull(expressionLanguage, &quot;expressionLanguage&quot;);</span>
<span class="fc" id="L61">        this.expressionLanguage = expressionLanguage;</span>
<span class="fc" id="L62">    }</span>
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars) {
<span class="fc" id="L72">        return interpolate(message, vars, false);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive) {
<span class="fc" id="L84">        return parse(message, vars, recursive, null);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数をメッセージコードとして解決します。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive,
            final MessageResolver messageResolver) {
<span class="fc" id="L99">        return parse(message, vars, recursive, messageResolver);</span>
    }
    
    /**
     * メッセージをパースし、変数に値を差し込み、EL式を評価する。
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    protected String parse(final String message, final Map&lt;String, ?&gt; vars, boolean recursive, final MessageResolver messageResolver) {
        
        // 評価したメッセージを格納するバッファ。
<span class="fc" id="L112">        final StringBuilder sb = new StringBuilder(message.length());</span>
        
        /*
         * 変数とEL式を解析する際に使用する、スタック変数。
         * 式の開始が現れたらスタックに積み、式の終了が現れたらスタックから全てを取り出す。
         * スタックに積まれるのは、1つ文の変数またはEL式。
         */
<span class="fc" id="L119">        final LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;();</span>
        
<span class="fc" id="L121">        final int length = message.length();</span>
        
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for(int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L124">            final char c = message.charAt(i);</span>
            
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if(StackUtils.equalsTopElement(stack, &quot;\\&quot;)) {</span>
                // 直前の文字がエスケープ文字の場合、エスケープ文字として結合する。
<span class="fc" id="L128">                String escapedChar = StackUtils.popup(stack) + c;</span>
                
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if(!stack.isEmpty()) {</span>
                    // 取り出した後もスタックがある場合は、式の途中であるため、再度スタックに積む。
<span class="fc" id="L132">                    stack.push(escapedChar);</span>
                    
                } else {
                    // 取り出した後にスタックがない場合は、エスケープを解除して通常の文字として積む。
<span class="fc" id="L136">                    sb.append(c);</span>
                    
                }
                
<span class="fc bfc" id="L140" title="All 2 branches covered.">            } else if(c == '\\') {</span>
                // エスケープ文字の場合はスタックに積む。
<span class="fc" id="L142">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L144" title="All 2 branches covered.">            } else if(c == '$') {</span>
<span class="fc" id="L145">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L147" title="All 2 branches covered.">            } else if(c == '{') {</span>
                
<span class="pc bpc" id="L149" title="1 of 4 branches missed.">                if(!stack.isEmpty() &amp;&amp; !StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;$&quot;, &quot;{&quot;})) {</span>
                    // スタックの先頭が式の開始形式でない場合
<span class="nc" id="L151">                    throw new MessageParseException(message, &quot;expression not start with '{' or '$'&quot;);</span>
                    
                } else {
<span class="fc" id="L154">                    stack.push(String.valueOf(c));</span>
                }
                
                
<span class="fc bfc" id="L158" title="All 2 branches covered.">            } else if(c == '}') {</span>
                
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if(StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;{&quot;, &quot;$&quot;})) {</span>
                    // 式の終わりの場合は、式を取り出し評価する。
<span class="fc" id="L162">                    String expression = StackUtils.popupAndConcat(stack) + c;</span>
                    
                    // エスケープを解除する
<span class="fc" id="L165">                    expression = Utils.removeEscapeChar(expression, '\\');</span>
                    
<span class="fc" id="L167">                    String result = evaluate(expression, vars, recursive, messageResolver);</span>
<span class="fc" id="L168">                    sb.append(result);</span>
                    
<span class="fc" id="L170">                } else {</span>
<span class="fc" id="L171">                    sb.append(c);</span>
                    
                }
                
            } else {
                
<span class="fc bfc" id="L177" title="All 2 branches covered.">                if(stack.isEmpty()) {</span>
<span class="fc" id="L178">                    sb.append(c);</span>
                    
                } else {
<span class="fc" id="L181">                    stack.push(String.valueOf(c));</span>
                }
                
            }
            
        }
        
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if(!stack.isEmpty()) {</span>
<span class="fc" id="L189">            String val = StackUtils.popupAndConcat(stack);</span>
<span class="fc" id="L190">            val = Utils.removeEscapeChar(val, '\\');</span>
<span class="fc" id="L191">            sb.append(val);</span>
        }
        
<span class="fc" id="L194">        return sb.toString();</span>
    }
    
    private String evaluate(final String expression, final Map&lt;String, ?&gt; values, final boolean recursive,
            final MessageResolver messageResolver) {
        
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if(expression.startsWith(&quot;{&quot;)) {</span>
            // 変数の置換の場合
<span class="fc" id="L202">            final String varName = expression.substring(1, expression.length()-1);</span>
            
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if(values.containsKey(varName)) {</span>
                // 該当するキーが存在する場合
<span class="fc" id="L206">                final Object value = values.get(varName);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                final String eval = (value == null) ? &quot;&quot; : value.toString();</span>
<span class="pc bpc" id="L208" title="1 of 4 branches missed.">                if(!eval.isEmpty() &amp;&amp; recursive) {</span>
<span class="fc" id="L209">                    return parse(eval, values, recursive, messageResolver);</span>
                } else {
<span class="fc" id="L211">                    return eval;</span>
                }
                
<span class="fc bfc" id="L214" title="All 2 branches covered.">            } else if(messageResolver != null) {</span>
                // メッセージコードをとして解決をする。
<span class="fc" id="L216">                final Optional&lt;String&gt; eval = messageResolver.getMessage(varName);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if(!eval.isPresent()) {</span>
                    // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L219">                    return String.format(&quot;{%s}&quot;, varName);</span>
                }
                
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                if(recursive) {</span>
<span class="fc" id="L223">                    return parse(eval.get(), values, recursive, messageResolver);</span>
                } else {
<span class="nc" id="L225">                    return eval.get();</span>
                }
                
            } else {
                // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L230">                return expression.toString();</span>
            }
            
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        } else if(expression.startsWith(&quot;${&quot;)) {</span>
            // EL式で処理する
<span class="fc" id="L235">            final String expr = expression.substring(2, expression.length()-1);</span>
<span class="fc" id="L236">            final String eval = evaluateExpression(expr, values);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if(recursive) {</span>
<span class="fc" id="L238">                return parse(eval, values, recursive, messageResolver);</span>
            } else {
<span class="fc" id="L240">                return eval;</span>
            }
            
        }
        
<span class="nc" id="L245">        throw new MessageParseException(expression, &quot;not support expression.&quot;);</span>
        
    }
    
    /**
     * EL式を評価する。
     * @param expression EL式
     * @param values EL式中の変数。
     * @return 評価した式。
     * @throws ExpressionEvaluationException 
     */
    protected String evaluateExpression(final String expression, final Map&lt;String, ?&gt; values) throws ExpressionEvaluationException {
        
<span class="fc" id="L258">        final Map&lt;String, Object&gt; context = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L259">        context.putAll(values);</span>
        
        // フォーマッターの追加
<span class="fc" id="L262">        context.computeIfAbsent(&quot;formatter&quot;, key -&gt; new Formatter());</span>
        
        /*
         * JEXLで存在しない変数名の場合、nullが帰ってくるため、null判定を行う。
         */
<span class="fc" id="L267">        Object eval = expressionLanguage.evaluate(expression, context);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        String value = eval == null ? &quot;&quot; : eval.toString();</span>
        
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if(logger.isTraceEnabled()) {</span>
<span class="nc" id="L271">            logger.trace(&quot;evaluate expression language: expression='{}' ===&gt; value='{}'&quot;, expression, value);</span>
        }
        
<span class="fc" id="L274">        return value;</span>
    }
    
    /**
     * EL式を解析する実装クラスを取得する。
     * @return
     */
    public ExpressionLanguage getExpressionLanguage() {
<span class="nc" id="L282">        return expressionLanguage;</span>
    }
    
    /**
     * EL式を解析する実装クラスを設定する。
     * @param expressionLanguage EL式の解析するクラスの実装。
     */
    public void setExpressionLanguage(ExpressionLanguage expressionLanguage) {
<span class="fc" id="L290">        this.expressionLanguage = expressionLanguage;</span>
<span class="fc" id="L291">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>