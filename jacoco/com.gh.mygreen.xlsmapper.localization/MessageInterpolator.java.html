<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageInterpolator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.localization</a> &gt; <span class="el_source">MessageInterpolator.java</span></div><h1>MessageInterpolator.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.localization;

import java.util.Formatter;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.gh.mygreen.xlsmapper.expression.ExpressionEvaluationException;
import com.gh.mygreen.xlsmapper.expression.ExpressionLanguage;
import com.gh.mygreen.xlsmapper.expression.ExpressionLanguageJEXLImpl;
import com.gh.mygreen.xlsmapper.util.ArgUtils;
import com.gh.mygreen.xlsmapper.util.StackUtils;
import com.gh.mygreen.xlsmapper.util.Utils;


/**
 * 名前付き変数のメッセージをフォーマットするクラス。
 * &lt;p&gt;&lt;code&gt;{...}&lt;/code&gt;の場合、変数を単純に置換する。&lt;/p&gt;
 * &lt;p&gt;&lt;code&gt;${...}&lt;/code&gt;の場合、EL式を利用し処理する。&lt;/p&gt;
 * &lt;p&gt;文字'$', '{', '}'は特殊文字のため、&lt;code&gt;\&lt;/code&gt;でエスケープを行う。&lt;/p&gt;
 * &lt;p&gt;ELのパーサは、{@link ExpressionLanguage}の実装クラスで切り替え可能。&lt;/p&gt;
 * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数&lt;code&gt;{...}&lt;/code&gt;をメッセージ定義コードとして解決する。
 *   &lt;br&gt;ただし、メッセージ変数で指定されている変数が優先される。
 * &lt;/p&gt;
 * 
 * @since 2.0
 * @author T.TSUCHIE
 *
 */
public class MessageInterpolator {
    
<span class="fc" id="L37">    private static final Logger logger = LoggerFactory.getLogger(MessageInterpolator.class);</span>
    
    private ExpressionLanguage expressionLanguage;
    
    /**
     * デフォルトのコンストラクタ
     * &lt;p&gt;式言語の処理実装として、JEXLの{@link ExpressionLanguageJEXLImpl} が設定されます。
     * 
     */
<span class="fc" id="L46">    public MessageInterpolator() {</span>
<span class="fc" id="L47">        this.expressionLanguage = new ExpressionLanguageJEXLImpl();</span>
        
<span class="fc" id="L49">    }</span>
    
    /**
     * 再帰処理の最大回数
     */
<span class="fc" id="L54">    private int maxRecursiveDepth = 5;</span>
    
    /**
     * 式言語の実装を指定するコンストラクタ
     * @param expressionLanguage
     */
<span class="fc" id="L60">    public MessageInterpolator(final ExpressionLanguage expressionLanguage) {</span>
<span class="fc" id="L61">        ArgUtils.notNull(expressionLanguage, &quot;expressionLanguage&quot;);</span>
<span class="fc" id="L62">        this.expressionLanguage = expressionLanguage;</span>
<span class="fc" id="L63">    }</span>
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars) {
<span class="fc" id="L73">        return interpolate(message, vars, false);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive) {
<span class="fc" id="L85">        return parse(message, vars, recursive, 0, null);</span>
    }
    
    /**
     * メッセージを引数varsで指定した変数で補完する。
     * &lt;p&gt;{@link MessageResolver}を指定した場合、メッセージ中の変数をメッセージコードとして解決します。
     * 
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    public String interpolate(final String message, final Map&lt;String, ?&gt; vars, boolean recursive,
            final MessageResolver messageResolver) {
<span class="fc" id="L100">        return parse(message, vars, recursive, 0, messageResolver);</span>
    }
    
    /**
     * メッセージをパースし、変数に値を差し込み、EL式を評価する。
     * @param message 対象のメッセージ。
     * @param vars メッセージ中の変数に対する値のマップ。
     * @param recursive 変換したメッセージに対しても再帰的に処理するかどうか。
     * @param currentRecursiveDepth 現在の再帰処理回数。
     * @param messageResolver メッセージを解決するクラス。nullの場合、指定しないと同じ意味になります。
     * @return 補完したメッセージ。
     */
    protected String parse(final String message, final Map&lt;String, ?&gt; vars, boolean recursive, final int currentRecursiveDepth,
            final MessageResolver messageResolver) {
        
        // 評価したメッセージを格納するバッファ。
<span class="fc" id="L116">        final StringBuilder sb = new StringBuilder(message.length());</span>
        
        /*
         * 変数とEL式を解析する際に使用する、スタック変数。
         * 式の開始が現れたらスタックに積み、式の終了が現れたらスタックから全てを取り出す。
         * スタックに積まれるのは、1つ文の変数またはEL式。
         */
<span class="fc" id="L123">        final LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;();</span>
        
<span class="fc" id="L125">        final int length = message.length();</span>
        
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for(int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L128">            final char c = message.charAt(i);</span>
            
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if(StackUtils.equalsTopElement(stack, &quot;\\&quot;)) {</span>
                // 直前の文字がエスケープ文字の場合、エスケープ文字として結合する。
<span class="fc" id="L132">                String escapedChar = StackUtils.popup(stack) + c;</span>
                
<span class="fc bfc" id="L134" title="All 2 branches covered.">                if(!stack.isEmpty()) {</span>
                    // 取り出した後もスタックがある場合は、式の途中であるため、再度スタックに積む。
<span class="fc" id="L136">                    stack.push(escapedChar);</span>
                    
                } else {
                    // 取り出した後にスタックがない場合は、エスケープを解除して通常の文字として積む。
<span class="fc" id="L140">                    sb.append(c);</span>
                    
                }
                
<span class="fc bfc" id="L144" title="All 2 branches covered.">            } else if(c == '\\') {</span>
                // エスケープ文字の場合はスタックに積む。
<span class="fc" id="L146">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L148" title="All 2 branches covered.">            } else if(c == '$') {</span>
<span class="fc" id="L149">                stack.push(String.valueOf(c));</span>
                
<span class="fc bfc" id="L151" title="All 2 branches covered.">            } else if(c == '{') {</span>
                
<span class="pc bpc" id="L153" title="1 of 4 branches missed.">                if(!stack.isEmpty() &amp;&amp; !StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;$&quot;, &quot;{&quot;})) {</span>
                    // スタックの先頭が式の開始形式でない場合
<span class="nc" id="L155">                    throw new MessageParseException(message, &quot;expression not start with '{' or '$'&quot;);</span>
                    
                } else {
<span class="fc" id="L158">                    stack.push(String.valueOf(c));</span>
                }
                
                
<span class="fc bfc" id="L162" title="All 2 branches covered.">            } else if(c == '}') {</span>
                
<span class="fc bfc" id="L164" title="All 2 branches covered.">                if(StackUtils.equalsAnyBottomElement(stack, new String[]{&quot;{&quot;, &quot;$&quot;})) {</span>
                    // 式の終わりの場合は、式を取り出し評価する。
<span class="fc" id="L166">                    String expression = StackUtils.popupAndConcat(stack) + c;</span>
                    
                    // エスケープを解除する
<span class="fc" id="L169">                    expression = Utils.removeEscapeChar(expression, '\\');</span>
                    
<span class="fc" id="L171">                    String result = evaluate(expression, vars, recursive, currentRecursiveDepth, messageResolver);</span>
<span class="fc" id="L172">                    sb.append(result);</span>
                    
<span class="fc" id="L174">                } else {</span>
<span class="fc" id="L175">                    sb.append(c);</span>
                    
                }
                
            } else {
                
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if(stack.isEmpty()) {</span>
<span class="fc" id="L182">                    sb.append(c);</span>
                    
                } else {
<span class="fc" id="L185">                    stack.push(String.valueOf(c));</span>
                }
                
            }
            
        }
        
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if(!stack.isEmpty()) {</span>
<span class="fc" id="L193">            String val = StackUtils.popupAndConcat(stack);</span>
<span class="fc" id="L194">            val = Utils.removeEscapeChar(val, '\\');</span>
<span class="fc" id="L195">            sb.append(val);</span>
        }
        
<span class="fc" id="L198">        return sb.toString();</span>
    }
    
    private String evaluate(final String expression, final Map&lt;String, ?&gt; values, final boolean recursive,
            final int currentRecursiveDepth, final MessageResolver messageResolver) {
        
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if(expression.startsWith(&quot;{&quot;)) {</span>
            // 変数の置換の場合
<span class="fc" id="L206">            final String varName = expression.substring(1, expression.length()-1);</span>
            
<span class="fc bfc" id="L208" title="All 2 branches covered.">            if(values.containsKey(varName)) {</span>
                // 該当するキーが存在する場合（再帰評価は行わない）
<span class="fc" id="L210">                final Object value = values.get(varName);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                final String eval = (value == null) ? &quot;&quot; : value.toString();</span>
<span class="fc" id="L212">                return eval;</span>
                
<span class="fc bfc" id="L214" title="All 2 branches covered.">            } else if(messageResolver != null) {</span>
                // メッセージコードをとして解決をする。
<span class="fc" id="L216">                final Optional&lt;String&gt; eval = messageResolver.getMessage(varName);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if(!eval.isPresent()) {</span>
                    // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L219">                    return String.format(&quot;{%s}&quot;, varName);</span>
                }
                
<span class="fc bfc" id="L222" title="All 2 branches covered.">                if(recursivable(recursive, maxRecursiveDepth, currentRecursiveDepth, eval.get())) {</span>
<span class="fc" id="L223">                    return parse(eval.get(), values, recursive, currentRecursiveDepth + 1, messageResolver);</span>
                } else {
<span class="fc" id="L225">                    return eval.get();</span>
                }
                
            } else {
                // 該当するキーが存在しない場合は、値をそのまま返す。
<span class="fc" id="L230">                return expression.toString();</span>
            }
            
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        } else if(expression.startsWith(&quot;${&quot;)) {</span>
            // EL式を評価する（再帰評価は行わない）
<span class="fc" id="L235">            final String expr = expression.substring(2, expression.length()-1);</span>
<span class="fc" id="L236">            final String eval = evaluateExpression(expr, values);</span>
<span class="fc" id="L237">            return eval;</span>
            
        }
        
<span class="nc" id="L241">        throw new MessageParseException(expression, &quot;not support expression.&quot;);</span>
        
    }
    
    /**
     * 現在の再帰回数が最大回数に達しているかどうか。
     * 
     * @param recursive 再帰的に処理するかどうか。
     * @param maxRecursion 最大再帰回数
     * @param currentDepth 再帰回数
     * @param expression 再帰対象のメッセージ
     * @return 最大再帰回数を超えていなければfalseを返す。
     */
    private boolean recursivable(final boolean recursive, final int maxRecursion, final int currentDepth,
            String message) {

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if(!recursive) {</span>
<span class="nc" id="L258">            return false;</span>
        }

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if(maxRecursion &lt;= 0) {</span>
            // 再帰回数の制限なし。
<span class="nc" id="L263">            return true;</span>
        }

<span class="fc bfc" id="L266" title="All 2 branches covered.">        if(currentDepth &lt;= maxRecursion) {</span>
<span class="fc" id="L267">            return true;</span>
        }

<span class="fc" id="L270">        logger.warn(&quot;Over recursive depth : currentDepth={}, maxDepth={}, message={}.&quot;, currentDepth, maxRecursion, message);</span>

<span class="fc" id="L272">        return false;</span>

    }
    
    /**
     * EL式を評価する。
     * @param expression EL式
     * @param values EL式中の変数。
     * @return 評価した式。
     * @throws ExpressionEvaluationException 
     */
    protected String evaluateExpression(final String expression, final Map&lt;String, ?&gt; values) throws ExpressionEvaluationException {
        
<span class="fc" id="L285">        final Map&lt;String, Object&gt; context = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L286">        context.putAll(values);</span>
        
        // フォーマッターの追加
<span class="fc" id="L289">        context.computeIfAbsent(&quot;formatter&quot;, key -&gt; new Formatter());</span>
        
        /*
         * 以下のケースの時、評価値はnullが返されるため、空文字に変換する。
         * ・JEXLで存在しない変数名のとき。
         * ・ELインジェクション対象の式のとき
         */
<span class="fc" id="L296">        String evalValue = Objects.toString(expressionLanguage.evaluate(expression, context), &quot;&quot;);</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if(logger.isTraceEnabled()) {</span>
<span class="nc" id="L298">            logger.trace(&quot;evaluate expression language: expression='{}' ===&gt; value='{}'&quot;, expression, evalValue);</span>
        }
        
<span class="fc" id="L301">        return evalValue;</span>
    }
    
    /**
     * EL式を解析する実装クラスを取得する。
     * @return
     */
    public ExpressionLanguage getExpressionLanguage() {
<span class="nc" id="L309">        return expressionLanguage;</span>
    }
    
    /**
     * EL式を解析する実装クラスを設定する。
     * @param expressionLanguage EL式の解析するクラスの実装。
     */
    public void setExpressionLanguage(ExpressionLanguage expressionLanguage) {
<span class="nc" id="L317">        this.expressionLanguage = expressionLanguage;</span>
<span class="nc" id="L318">    }</span>
    
    /**
     * 評価した変数やEL式を再帰的に処するときの最大回数を取得します。
     * 
     * @since 2.3
     * @return 再帰的に処するときの最大回数。
     */
    public int getMaxRecursiveDepth() {
<span class="nc" id="L327">        return maxRecursiveDepth;</span>
    }
    
    /**
     * 評価した変数やEL式を再帰的に処するときの最大回数を設定します。
     * 
     * @since 2.3
     * @param maxRecursiveDepth 再帰的に処するときの最大回数。{@literal -1} のとき制限はありません。
     */
    public void setMaxRecursiveDepth(int maxRecursiveDepth) {
<span class="fc" id="L337">        this.maxRecursiveDepth = maxRecursiveDepth;</span>
<span class="fc" id="L338">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>