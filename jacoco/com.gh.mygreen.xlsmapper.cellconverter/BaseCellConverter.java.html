<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseCellConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.cellconverter</a> &gt; <span class="el_source">BaseCellConverter.java</span></div><h1>BaseCellConverter.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.cellconverter;

import java.util.Collection;
import java.util.Map;
import java.util.Optional;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.FormulaEvaluator;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.VerticalAlignment;
import org.apache.poi.ss.usermodel.Workbook;

import com.gh.mygreen.xlsmapper.Configuration;
import com.gh.mygreen.xlsmapper.XlsMapperException;
import com.gh.mygreen.xlsmapper.fieldaccessor.FieldAccessor;
import com.gh.mygreen.xlsmapper.fieldprocessor.ProcessCase;
import com.gh.mygreen.xlsmapper.localization.MessageBuilder;
import com.gh.mygreen.xlsmapper.textformatter.TextFormatter;
import com.gh.mygreen.xlsmapper.textformatter.TextParseException;
import com.gh.mygreen.xlsmapper.util.CellPosition;
import com.gh.mygreen.xlsmapper.util.POIUtils;
import com.gh.mygreen.xlsmapper.util.Utils;
import com.gh.mygreen.xlsmapper.validation.fieldvalidation.FieldFormatter;

/**
 * {@link CellConverter}を実装するときのベースとなる抽象クラス。
 * 通常は、このクラスを継承して{@link CellConverter}を実装します。
 *
 * @version 2.0
 * @author T.TSUCHIE
 *
 */
public abstract class BaseCellConverter&lt;T&gt; implements CellConverter&lt;T&gt;, FieldFormatter&lt;T&gt; {

    /**
     * フィールド情報
     */
    protected final FieldAccessor field;

    /**
     * システム設定
     */
    protected final Configuration configuration;

    /**
     * 値をトリムするかどうか
     */
    protected boolean trimmed;

    /**
     * 初期値 - 初期値を持たない場合は空
     */
<span class="fc" id="L56">    protected OptionalProcessCase&lt;T&gt; defaultValue = OptionalProcessCase.empty();</span>

    /**
     * セルの設定 - セルを縮小して表示するかどうか
     */
    protected boolean shrinktToFit;

    /**
     * セルの設定 - 折り返して全体を表示するかどうか
     */
    protected boolean wrapText;

    /**
     * セルの設定 - インデント
     */
    protected short indent;

    /**
     * セルの設定 - 横位置
     */
<span class="fc" id="L76">    protected Optional&lt;HorizontalAlignment&gt; horizontalAlignment = Optional.empty();</span>

    /**
     * セルの設定 - 縦位置
     */
<span class="fc" id="L81">    protected Optional&lt;VerticalAlignment&gt; verticalAlignment = Optional.empty();</span>

    /**
     * 書き込み時の数式を設定する
     */
<span class="fc" id="L86">    protected Optional&lt;CellFormulaHandler&gt; formulaHandler = Optional.empty();</span>

    /**
     * 文字列とオブジェクトを相互変換するフォーマッタ
     */
    protected TextFormatter&lt;T&gt; textFormatter;

<span class="fc" id="L93">    public BaseCellConverter(final FieldAccessor field, final Configuration config) {</span>
<span class="fc" id="L94">        this.field = field;</span>
<span class="fc" id="L95">        this.configuration = config;</span>
<span class="fc" id="L96">    }</span>

    @Override
    public T toObject(final Cell cell) throws XlsMapperException {

<span class="fc" id="L101">        final ProcessCase processCase = ProcessCase.Load;</span>
<span class="fc" id="L102">        final String formattedValue = Utils.trim(configuration.getCellFormatter().format(cell), trimmed);</span>

        // デフォルト値の設定
<span class="fc bfc" id="L105" title="All 4 branches covered.">        if(isEmptyCell(formattedValue, cell) &amp;&amp; defaultValue.isPresent(processCase)) {</span>
<span class="fc" id="L106">            return defaultValue.get(processCase);</span>
        }

        // 数式のセルの場合、予め評価しておく
        final Cell evaluatedCell;
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if(cell.getCellTypeEnum().equals(CellType.FORMULA)) {</span>
<span class="fc" id="L112">            final Workbook workbook = cell.getSheet().getWorkbook();</span>
<span class="fc" id="L113">            final CreationHelper helper = workbook.getCreationHelper();</span>
<span class="fc" id="L114">            final FormulaEvaluator evaluator = helper.createFormulaEvaluator();</span>

<span class="fc" id="L116">            evaluatedCell = evaluator.evaluateInCell(cell);</span>
<span class="fc" id="L117">        } else {</span>
<span class="fc" id="L118">            evaluatedCell = cell;</span>
        }

<span class="fc" id="L121">        return parseCell(evaluatedCell, formattedValue);</span>
    }

    /**
     * セルをJavaのオブジェクト型に変換します。
     * @param evaluatedCell 数式を評価済みのセル
     * @param formattedValue フォーマット済みのセルの値。トリミングなど適用済み。
     * @return 変換した値を返す。
     * @throws TypeBindException 変換に失敗した場合
     */
    protected abstract T parseCell(Cell evaluatedCell, String formattedValue) throws TypeBindException;

    /**
     * セルの値をパースしJavaオブジェクトに型変換するとこに失敗したときの例外{@link TypeBindException}を作成します。
     * @since 2.0
     * @param error 例外情報
     * @param cell パースに失敗したセル
     * @param cellValue パースに失敗した値
     * @return マッピングに失敗したときの例外のインスタンス
     */
    public TypeBindException newTypeBindExceptionOnParse(final Exception error,  final Cell cell, final Object cellValue) {

<span class="fc" id="L143">        final String message = MessageBuilder.create(&quot;cell.typeBind.failParse&quot;)</span>
<span class="fc" id="L144">                .var(&quot;property&quot;, field.getNameWithClass())</span>
<span class="fc" id="L145">                .var(&quot;cellAddress&quot;, POIUtils.formatCellAddress(cell))</span>
<span class="fc" id="L146">                .var(&quot;cellValue&quot;, cellValue.toString())</span>
<span class="fc" id="L147">                .varWithClass(&quot;type&quot;, field.getType())</span>
<span class="fc" id="L148">                .format();</span>

<span class="fc" id="L150">        final TypeBindException bindException = new TypeBindException(error, message, field.getType(), cellValue);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if(error instanceof TextParseException) {</span>
<span class="fc" id="L152">            bindException.addAllMessageVars(((TextParseException)error).getErrorVariables());</span>
        }

<span class="fc" id="L155">        return bindException;</span>

    }

    /**
     * セルの値をパースしセルの値をJavaオブジェクトに型変換するとに失敗したときの例外{@link TypeBindException}を作成します。
     * @since 2.0
     * @param cell パースに失敗したセル
     * @param cellValue パースに失敗した値
     * @return マッピングに失敗したときの例外のインスタンス
     */
    public TypeBindException newTypeBindExceptionOnParse(final Cell cell, final Object cellValue) {

<span class="nc" id="L168">        final String message = MessageBuilder.create(&quot;cell.typeBind.failParse&quot;)</span>
<span class="nc" id="L169">                .var(&quot;property&quot;, field.getNameWithClass())</span>
<span class="nc" id="L170">                .var(&quot;cellAddress&quot;, POIUtils.formatCellAddress(cell))</span>
<span class="nc" id="L171">                .var(&quot;cellValue&quot;, cellValue.toString())</span>
<span class="nc" id="L172">                .varWithClass(&quot;type&quot;, field.getType())</span>
<span class="nc" id="L173">                .format();</span>

<span class="nc" id="L175">        final TypeBindException bindException = new TypeBindException(message, field.getType(), cellValue);</span>

<span class="nc" id="L177">        return bindException;</span>

    }

    /**
     * セルの値が空かどうか判定します。
     * &lt;p&gt;読み込み時のセルの値をJavaオブジェクトにマッピングする際に呼ばれます。&lt;/p&gt;
     * &lt;p&gt;
     *   通常は、{@code formattedValue.isEmpty()} で判定しますが、
     *   ハイパーリンクのようにマッピング対象の値がセルの値だけではない場合は、
     *   オーバライドして判定方法を変更します。
     * &lt;/p&gt;
     *
     * @param formattedValue フォーマットしたセルの値
     * @param cell 評価対象のセル
     * @return trueの場合、空と判定する。
     */
    protected boolean isEmptyCell(final String formattedValue, final Cell cell) {
<span class="fc" id="L195">        return formattedValue.isEmpty();</span>
    }

    @Override
    public Cell toCell(final T targetValue, final Object targetBean, final Sheet sheet, final CellPosition address) throws XlsMapperException {

<span class="fc" id="L201">        final ProcessCase processCase = ProcessCase.Save;</span>
<span class="fc" id="L202">        final Cell cell = POIUtils.getCell(sheet, address);</span>

<span class="fc" id="L204">        final CellStyleProxy cellStyle = new CellStyleProxy(cell);</span>

        // セルの制御の設定
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if(shrinktToFit) {</span>
<span class="fc" id="L208">            cellStyle.setShrinkToFit();</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        } else if(wrapText) {</span>
<span class="fc" id="L211">            cellStyle.setWrapText();</span>
        }

        // 横位置
<span class="fc" id="L215">        horizontalAlignment.ifPresent(align -&gt; cellStyle.setHorizontalAlignment(align));</span>

        // インデント
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if(indent &gt;= 0) {</span>
<span class="fc" id="L219">            cellStyle.setIndent(indent);</span>
        }

        // 縦位置
<span class="fc" id="L223">        verticalAlignment.ifPresent(align -&gt; cellStyle.setVerticalAlignment(align));</span>

        // デフォルト値の設定
        final T cellValue;
<span class="fc bfc" id="L227" title="All 4 branches covered.">        if(targetValue == null &amp;&amp; defaultValue.isPresent(processCase)) {</span>
<span class="fc" id="L228">            cellValue = defaultValue.get(processCase);</span>
        } else {
<span class="fc" id="L230">            cellValue = targetValue;</span>
        }

        // 各書式に沿った値の設定
<span class="fc" id="L234">        setupCell(cell, Optional.ofNullable(cellValue));</span>

        // 数式の設定
<span class="fc" id="L237">        formulaHandler.ifPresent(handler -&gt; {</span>
<span class="fc bfc" id="L238" title="All 4 branches covered.">            if(isEmptyValue(cellValue, configuration) || handler.isPrimaryFormula()) {</span>
<span class="fc" id="L239">                handler.handleFormula(field, configuration, cell, targetBean);</span>
            }
<span class="fc" id="L241">        });</span>

<span class="fc" id="L243">        return cell;</span>
    }

    /**
     * オブジェクトの値を空と判定する
     * @param obj 判定対象の値
     * @param config システム情報
     * @return trueの場合、空と判定する。
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    protected boolean isEmptyValue(final T obj, final Configuration config) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if(obj == null) {</span>
<span class="fc" id="L255">            return true;</span>
        }

<span class="fc bfc" id="L258" title="All 2 branches covered.">        if(obj instanceof String) {</span>
<span class="fc" id="L259">            return ((String)obj).isEmpty();</span>
        }

<span class="pc bpc" id="L262" title="1 of 4 branches missed.">        if(char.class.isAssignableFrom(obj.getClass()) || obj instanceof Character) {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            return ((Character)obj) == '\u0000';</span>
        }

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if(obj.getClass().isArray()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            return ((Object[])obj).length == 0;</span>
        }

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if(obj instanceof Collection) {</span>
<span class="nc" id="L271">            return ((Collection)obj).isEmpty();</span>
        }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if(obj instanceof Map) {</span>
<span class="nc" id="L275">            return ((Map)obj).isEmpty();</span>
        }

<span class="fc" id="L278">        return false;</span>
    }

    /**
     * 書き込み時のセルに値と書式を設定します。
     * @param cell 設定対象のセル
     * @param cellValue 設定対象の値。
     * @throws TypeBindException 変換に失敗した場合
     */
    protected abstract void setupCell(Cell cell, Optional&lt;T&gt; cellValue) throws TypeBindException;

    /**
     * フィールド情報を取得します。
     * @return フィールド情報
     */
    public FieldAccessor getField() {
<span class="fc" id="L294">        return field;</span>
    }

    /**
     * システム情報を取得します。
     * @return システム情報
     */
    public Configuration getConfiguration() {
<span class="fc" id="L302">        return configuration;</span>
    }

    @Override
    public String format(T value) {
<span class="fc" id="L307">        return textFormatter.format(value);</span>
    }

    /**
     * 値をトリミングするかどうか設定する
     * @param trimmed trueの場合、トリムする。
     */
    public void setTrimmed(boolean trimmed) {
<span class="fc" id="L315">        this.trimmed = trimmed;</span>
<span class="fc" id="L316">    }</span>

    /**
     * 値をトリミングするかどうか。
     * @return trueの場合、トリムする。
     */
    public boolean isTrimmed() {
<span class="nc" id="L323">        return trimmed;</span>
    }

    /**
     * 初期値を設定します。
     * @param defaultValue 初期値となるオブジェクト。
     * @param cases 該当する処理ケース
     */
    public void setDefaultValue(T defaultValue, ProcessCase[] cases) {
<span class="fc" id="L332">        this.defaultValue = OptionalProcessCase.of(defaultValue, cases);</span>
<span class="fc" id="L333">    }</span>

    /**
     * 初期値を取得します。
     * @return 設定されていない場合、空を返します。
     */
    public OptionalProcessCase&lt;T&gt; getDefaultValue() {
<span class="nc" id="L340">        return defaultValue;</span>
    }

    /**
     * セルの設定 - セルを縮小して表示するかどうか設定します。
     * @param shrinktToFit trueの場合、セルを縮小して表示します。
     */
    public void setShrinktToFit(boolean shrinktToFit) {
<span class="fc" id="L348">        this.shrinktToFit = shrinktToFit;</span>
<span class="fc" id="L349">    }</span>

    /**
     * セルの設定 - セルを縮小して表示するかどうか。
     * @return trueの場合、セルを縮小して表示します。
     */
    public boolean isShrinktToFit() {
<span class="nc" id="L356">        return shrinktToFit;</span>
    }

    /**
     * セルの設定 - 折り返して全体を表示するかどうか設定します。
     * @param wrapText trueの場合、折り返して全体を表示します。
     */
    public void setWrapText(boolean wrapText) {
<span class="fc" id="L364">        this.wrapText = wrapText;</span>
<span class="fc" id="L365">    }</span>

    /**
     * セルの設定 - 折り返して全体を表示するかどうか。
     * @return trueの場合、折り返して全体を表示します。
     */
    public boolean isWrapText() {
<span class="nc" id="L372">        return wrapText;</span>
    }

    /**
     * セルの設定 - インデント
     * @return 0以上の場合、有効。
     */
    public short getIndent() {
<span class="nc" id="L380">        return indent;</span>
    }

    /**
     * セルの設定 - インデント
     * @param indent 0以上の場合、有効。
     */
    public void setIndent(short indent) {
<span class="fc" id="L388">        this.indent = indent;</span>
<span class="fc" id="L389">    }</span>

    /**
     * セルの設定 - 横位置
     * @return 横位置。設定がない場合は空を返す。
     */
    public Optional&lt;HorizontalAlignment&gt; getHorizontalAlignment() {
<span class="nc" id="L396">        return horizontalAlignment;</span>
    }

    /**
     * セルの設定 - 横位置
     * @param horizontalAlignment 横位置
     */
    public void setHorizontalAlignment(HorizontalAlignment horizontalAlignment) {
<span class="fc" id="L404">        this.horizontalAlignment = Optional.ofNullable(horizontalAlignment);</span>
<span class="fc" id="L405">    }</span>

    /**
     *  セルの設定 - 縦位置
     * @return 縦位置。設定がない場合は空を返す。
     */
    public Optional&lt;VerticalAlignment&gt; getVerticalAlignment() {
<span class="nc" id="L412">        return verticalAlignment;</span>
    }

    /**
     * セルの設定 - 縦位置
     * @param verticalAlignment 縦位置
     */
    public void setVerticalAlignment(VerticalAlignment verticalAlignment) {
<span class="fc" id="L420">        this.verticalAlignment = Optional.ofNullable(verticalAlignment);</span>
<span class="fc" id="L421">    }</span>

    /**
     * 数式を処理するハンドラを設定する
     * @param formulaHandler 数式を処理するハンドラを
     */
    public void setFormulaHandler(CellFormulaHandler formulaHandler) {
<span class="fc" id="L428">        this.formulaHandler = Optional.of(formulaHandler);</span>
<span class="fc" id="L429">    }</span>

    /**
     * 文字列とオブジェクトを相互変換するフォーマッタを取得します。
     * @param textFormatter フォーマッタ
     */
    public void setTextFormatter(TextFormatter&lt;T&gt; textFormatter) {
<span class="fc" id="L436">        this.textFormatter = textFormatter;</span>
<span class="fc" id="L437">    }</span>

    /**
     * 文字列とオブジェクトを相互変換するフォーマッタを取得します。
     * @return フォーマッタ
     */
    public TextFormatter&lt;T&gt; getTextFormatter() {
<span class="fc" id="L444">        return textFormatter;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>