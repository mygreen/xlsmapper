<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VerticalRecordsProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.fieldprocessor.impl</a> &gt; <span class="el_source">VerticalRecordsProcessor.java</span></div><h1>VerticalRecordsProcessor.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.fieldprocessor.impl;

import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataValidation;
import org.apache.poi.ss.usermodel.Name;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.AreaReference;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellRangeAddressList;
import org.apache.poi.ss.util.CellReference;

import com.gh.mygreen.xlsmapper.AnnotationInvalidException;
import com.gh.mygreen.xlsmapper.Configuration;
import com.gh.mygreen.xlsmapper.LoadingWorkObject;
import com.gh.mygreen.xlsmapper.NeedProcess;
import com.gh.mygreen.xlsmapper.SavingWorkObject;
import com.gh.mygreen.xlsmapper.XlsMapperException;
import com.gh.mygreen.xlsmapper.annotation.ArrayDirection;
import com.gh.mygreen.xlsmapper.annotation.RecordTerminal;
import com.gh.mygreen.xlsmapper.annotation.XlsArrayColumns;
import com.gh.mygreen.xlsmapper.annotation.XlsColumn;
import com.gh.mygreen.xlsmapper.annotation.XlsIgnorable;
import com.gh.mygreen.xlsmapper.annotation.XlsMapColumns;
import com.gh.mygreen.xlsmapper.annotation.XlsNestedRecords;
import com.gh.mygreen.xlsmapper.annotation.XlsRecordFinder;
import com.gh.mygreen.xlsmapper.annotation.XlsRecordOption;
import com.gh.mygreen.xlsmapper.annotation.XlsRecordOption.OverOperation;
import com.gh.mygreen.xlsmapper.annotation.XlsRecordOption.RemainedOperation;
import com.gh.mygreen.xlsmapper.annotation.XlsVerticalRecords;
import com.gh.mygreen.xlsmapper.cellconverter.CellConverter;
import com.gh.mygreen.xlsmapper.cellconverter.TypeBindException;
import com.gh.mygreen.xlsmapper.fieldaccessor.FieldAccessor;
import com.gh.mygreen.xlsmapper.fieldprocessor.AbstractFieldProcessor;
import com.gh.mygreen.xlsmapper.fieldprocessor.CellNotFoundException;
import com.gh.mygreen.xlsmapper.fieldprocessor.MergedRecord;
import com.gh.mygreen.xlsmapper.fieldprocessor.NestedRecordMergedSizeException;
import com.gh.mygreen.xlsmapper.fieldprocessor.ProcessCase;
import com.gh.mygreen.xlsmapper.fieldprocessor.RecordFinder;
import com.gh.mygreen.xlsmapper.fieldprocessor.RecordHeader;
import com.gh.mygreen.xlsmapper.fieldprocessor.RecordMethodCache;
import com.gh.mygreen.xlsmapper.fieldprocessor.RecordMethodFacatory;
import com.gh.mygreen.xlsmapper.fieldprocessor.RecordsProcessorUtil;
import com.gh.mygreen.xlsmapper.localization.MessageBuilder;
import com.gh.mygreen.xlsmapper.util.CellFinder;
import com.gh.mygreen.xlsmapper.util.CellPosition;
import com.gh.mygreen.xlsmapper.util.FieldAccessorUtils;
import com.gh.mygreen.xlsmapper.util.POIUtils;
import com.gh.mygreen.xlsmapper.util.Utils;
import com.gh.mygreen.xlsmapper.validation.fieldvalidation.FieldFormatter;
import com.gh.mygreen.xlsmapper.xml.AnnotationReadException;
import com.gh.mygreen.xlsmapper.xml.AnnotationReader;


/**
 * アノテーション{@link XlsVerticalRecords}を処理するクラス。
 *
 * @version 2.1
 * @author Naoki Takezoe
 * @author T.TSUCHIE
 *
 */
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">public class VerticalRecordsProcessor extends AbstractFieldProcessor&lt;XlsVerticalRecords&gt;{</span>

    @Override
    public void loadProcess(final Sheet sheet, final Object beansObj, final XlsVerticalRecords anno,
            final FieldAccessor accessor, final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

<span class="fc bfc" id="L87" title="All 2 branches covered.">        if(!accessor.isWritable()) {</span>
            // セルの値を書き込むメソッド／フィールドがない場合はスキップ
<span class="fc" id="L89">            return;</span>
        }
        
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if(!Utils.isLoadCase(anno.cases())) {</span>
<span class="nc" id="L93">            return;</span>
        }

<span class="fc" id="L96">        final Class&lt;?&gt; clazz = accessor.getType();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if(Collection.class.isAssignableFrom(clazz)) {</span>

<span class="fc" id="L99">            Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            if(recordClass == Object.class) {</span>
<span class="fc" id="L101">                recordClass = accessor.getComponentType();</span>
            }

<span class="fc" id="L104">            final List&lt;?&gt; value = loadRecords(sheet, beansObj, anno, accessor, recordClass, config, work);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">            if(value != null) {</span>
                @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="fc" id="L107">                Collection&lt;?&gt; collection = Utils.convertListToCollection(value, (Class&lt;Collection&gt;)clazz, config.getBeanFactory());</span>
<span class="fc" id="L108">                accessor.setValue(beansObj, collection);</span>
            }
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        } else if(clazz.isArray()) {</span>

<span class="fc" id="L112">            Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if(recordClass == Object.class) {</span>
<span class="fc" id="L114">                recordClass = accessor.getComponentType();</span>
            }

<span class="fc" id="L117">            final List&lt;?&gt; value = loadRecords(sheet, beansObj, anno, accessor, recordClass, config, work);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if(value != null) {</span>
<span class="fc" id="L119">                final Object array = Array.newInstance(recordClass, value.size());</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                for(int i=0; i &lt; value.size(); i++) {</span>
<span class="fc" id="L121">                    Array.set(array, i, value.get(i));</span>
                }

<span class="fc" id="L124">                accessor.setValue(beansObj, array);</span>
            }

<span class="fc" id="L127">        } else {</span>
<span class="nc" id="L128">            throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.notSupportType&quot;)</span>
<span class="nc" id="L129">                    .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="nc" id="L130">                    .varWithAnno(&quot;anno&quot;, XlsVerticalRecords.class)</span>
<span class="nc" id="L131">                    .varWithClass(&quot;actualType&quot;, clazz)</span>
<span class="nc" id="L132">                    .var(&quot;expectedType&quot;, &quot;Collection(List/Set) or Array&quot;)</span>
<span class="nc" id="L133">                    .format());</span>
        }

<span class="fc" id="L136">    }</span>

   private List&lt;?&gt; loadRecords(final Sheet sheet, final Object beansObj, final XlsVerticalRecords anno, final FieldAccessor accessor,
           final Class&lt;?&gt; recordClass, final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

        // get table starting position
<span class="fc" id="L142">        final Optional&lt;CellPosition&gt; initPosition = getHeaderPosition(sheet, anno, accessor, config);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if(!initPosition.isPresent()) {</span>
<span class="fc" id="L144">            return null;</span>
        }

        // ラベルの設定
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if(Utils.isNotEmpty(anno.tableLabel())) {</span>
<span class="fc" id="L149">            final Optional&lt;Cell&gt; tableLabelCell = CellFinder.query(sheet, anno.tableLabel(), config).findOptional();</span>
<span class="fc" id="L150">            tableLabelCell.ifPresent(c -&gt; {</span>
<span class="fc" id="L151">                final String label = POIUtils.getCellContents(c, config.getCellFormatter());</span>
<span class="fc" id="L152">                accessor.setLabel(beansObj, label);</span>

<span class="fc" id="L154">            });</span>
        }

<span class="fc" id="L157">        final int initColumn = initPosition.get().getColumn();</span>
<span class="fc" id="L158">        final int initRow = initPosition.get().getRow();</span>

<span class="fc" id="L160">        int hColumn = initColumn;</span>
<span class="fc" id="L161">        int hRow = initRow;</span>

        // get header columns.
<span class="fc" id="L164">        final List&lt;RecordHeader&gt; headers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L165">        int rangeCount = 1;</span>
        while(true){
            try {
<span class="fc" id="L168">                Cell cell = POIUtils.getCell(sheet, hColumn, hRow);</span>
<span class="fc bfc" id="L169" title="All 4 branches covered.">                while(POIUtils.isEmptyCellContents(cell, config.getCellFormatter()) &amp;&amp; rangeCount &lt; anno.range()){</span>
<span class="fc" id="L170">                    cell = POIUtils.getCell(sheet, hColumn, hRow + rangeCount);</span>
<span class="fc" id="L171">                    rangeCount++;</span>
                }

<span class="fc" id="L174">                String cellValue = POIUtils.getCellContents(cell, config.getCellFormatter());</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">                if(Utils.isEmpty(cellValue)){</span>
<span class="fc" id="L176">                    break;</span>
                } /*else {
                    for(int j=hColumn; j &gt; initColumn; j--){
                        final Cell tmpCell = POIUtils.getCell(sheet, j, hRow);
                        if(!POIUtils.isEmptyCellContents(tmpCell, config.getCellFormatter())){
                            cell = tmpCell;
                            break;
                        }
                    }
                }*/

<span class="fc" id="L187">                headers.add(new RecordHeader(cellValue, cell.getRowIndex() - initRow));</span>
<span class="fc" id="L188">                hRow = hRow + rangeCount;</span>
<span class="fc" id="L189">                rangeCount = 1;</span>

                // 結合しているセルの場合は、はじめのセルだけ取得して、後は結合分スキップする。
<span class="fc" id="L192">                CellRangeAddress mergedRange = POIUtils.getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                if(mergedRange != null) {</span>
<span class="fc" id="L194">                    hRow = hRow + (mergedRange.getLastRow() - mergedRange.getFirstRow());</span>
                }

<span class="nc" id="L197">            } catch(ArrayIndexOutOfBoundsException ex){</span>
<span class="nc" id="L198">                break;</span>
<span class="fc" id="L199">            }</span>

<span class="fc bfc" id="L201" title="All 4 branches covered.">            if(anno.headerLimit() &gt; 0 &amp;&amp; headers.size() &gt;= anno.headerLimit()){</span>
<span class="fc" id="L202">                break;</span>
            }
        }

        // データ行の開始位置の調整
<span class="fc" id="L207">        hColumn += anno.headerRight();</span>
<span class="fc" id="L208">        CellPosition startPosition = CellPosition.of(initRow, hColumn);</span>

        // 独自の開始位置を指定する場合
<span class="fc" id="L211">        final Optional&lt;XlsRecordFinder&gt; finderAnno = accessor.getAnnotation(XlsRecordFinder.class);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if(finderAnno.isPresent()) {</span>
<span class="fc" id="L213">            final RecordFinder finder = config.createBean(finderAnno.get().value());</span>
<span class="fc" id="L214">            startPosition = finder.find(ProcessCase.Load, finderAnno.get().args(), sheet, startPosition, beansObj, config);</span>

        }

<span class="fc" id="L218">        return loadRecords(sheet, headers, anno, startPosition, 0, accessor, recordClass, config, work);</span>
   }

   private List&lt;?&gt; loadRecords(final Sheet sheet, final List&lt;RecordHeader&gt; headers,
           final XlsVerticalRecords anno,
           final CellPosition initPosition, final int parentMergedSize,
           final FieldAccessor accessor, final Class&lt;?&gt; recordClass,
           final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

<span class="fc" id="L227">        final List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L229">        final int initColumn = initPosition.getColumn();</span>
<span class="fc" id="L230">        final int initRow = initPosition.getRow();</span>

<span class="fc" id="L232">        final int maxColumn = initColumn + parentMergedSize;</span>
<span class="fc" id="L233">        int hColumn = initColumn;</span>

        // Check for columns
<span class="fc" id="L236">        RecordsProcessorUtil.checkColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>
<span class="fc" id="L237">        RecordsProcessorUtil.checkMapColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>
<span class="fc" id="L238">        RecordsProcessorUtil.checkArrayColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>

<span class="fc" id="L240">        RecordTerminal terminal = anno.terminal();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if(terminal == null){</span>
<span class="nc" id="L242">            terminal = RecordTerminal.Empty;</span>
        }

        // 各種レコードのコールバック用メソッドを抽出する
<span class="fc" id="L246">        final RecordMethodCache methodCache = new RecordMethodFacatory(work.getAnnoReader(), config)</span>
<span class="fc" id="L247">                .create(recordClass, ProcessCase.Load);</span>

        // レコードの見出しに対するカラム情報のキャッシュ
<span class="fc" id="L250">        final Map&lt;String, List&lt;FieldAccessor&gt;&gt; propertiesCache = new HashMap&lt;&gt;();</span>

        // カラムに対するConverterのキャッシュ
<span class="fc" id="L253">        final Map&lt;String, CellConverter&lt;?&gt;&gt; converterCache = new HashMap&lt;&gt;();</span>

<span class="fc" id="L255">        final int startHeaderIndex = getStartHeaderIndexForLoading(headers, recordClass, work.getAnnoReader(), config);</span>

        // get records
<span class="fc bfc" id="L258" title="All 2 branches covered.">        while(hColumn &lt; POIUtils.getColumns(sheet)){</span>

<span class="fc bfc" id="L260" title="All 4 branches covered.">            if(parentMergedSize &gt; 0 &amp;&amp; hColumn &gt;= maxColumn) {</span>
                // ネストしている処理のとき、最大の処理レコード数をチェックする。
<span class="fc" id="L262">                break;</span>
            }

<span class="fc" id="L265">            boolean emptyFlag = true;</span>
            // recordは、マッピング先のオブジェクトのインスタンス。
<span class="fc" id="L267">            final Object record = config.createBean(recordClass);</span>

            // パスの位置の変更
<span class="fc" id="L270">            work.getErrors().pushNestedPath(accessor.getName(), result.size());</span>

            // execute PreProcess listener
<span class="fc" id="L273">            methodCache.getListenerClasses().forEach(listenerClass -&gt; {</span>
<span class="fc" id="L274">                listenerClass.getPreLoadMethods().forEach(method -&gt; {</span>
<span class="fc" id="L275">                    Utils.invokeNeedProcessMethod(listenerClass.getObject(), method, record, sheet, config, work.getErrors(), ProcessCase.Load);</span>
<span class="fc" id="L276">                });</span>
<span class="fc" id="L277">            });</span>

            // execute PreProcess method
<span class="fc" id="L280">            methodCache.getPreLoadMethods().forEach(method -&gt; {</span>
<span class="fc" id="L281">                Utils.invokeNeedProcessMethod(record, method, record, sheet, config, work.getErrors(), ProcessCase.Load);</span>
<span class="fc" id="L282">            });</span>

<span class="fc" id="L284">            final List&lt;MergedRecord&gt; mergedRecords = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L286">            loadMapColumns(sheet, headers, mergedRecords, CellPosition.of(initRow, hColumn), recordClass, record, config, work);</span>

<span class="fc" id="L288">            loadArrayColumns(sheet, headers, mergedRecords, CellPosition.of(initRow, hColumn), recordClass, record, config, work);</span>

<span class="pc bpc" id="L290" title="1 of 4 branches missed.">            for(int i=0; i &lt; headers.size() &amp;&amp; hColumn &lt; POIUtils.getColumns(sheet); i++){</span>
<span class="fc" id="L291">                final RecordHeader headerInfo = headers.get(i);</span>
<span class="fc" id="L292">                int hRow = initRow + headerInfo.getInterval();</span>
<span class="fc" id="L293">                final Cell cell = POIUtils.getCell(sheet, hColumn, hRow);</span>

                // find end of the table
<span class="fc bfc" id="L296" title="All 2 branches covered.">                if(!POIUtils.isEmptyCellContents(cell, config.getCellFormatter())){</span>
<span class="fc" id="L297">                    emptyFlag = false;</span>
                }

<span class="fc bfc" id="L300" title="All 4 branches covered.">                if(terminal==RecordTerminal.Border &amp;&amp; i == startHeaderIndex){</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                    if(!POIUtils.getBorderTop(cell).equals(BorderStyle.NONE)){</span>
<span class="fc" id="L302">                        emptyFlag = false;</span>
                    } else {
<span class="fc" id="L304">                        emptyFlag = true;</span>
<span class="fc" id="L305">                        break;</span>
                    }
                }

<span class="fc bfc" id="L309" title="All 2 branches covered.">                if(!anno.terminateLabel().equals(&quot;&quot;)){</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if(Utils.matches(POIUtils.getCellContents(cell, config.getCellFormatter()), anno.terminateLabel(), config)){</span>
<span class="fc" id="L311">                        emptyFlag = true;</span>
<span class="fc" id="L312">                        break;</span>
                    }
                }

                // mapping from Excel columns to Object properties.
<span class="fc" id="L317">                final List&lt;FieldAccessor&gt; propeties = propertiesCache.computeIfAbsent(headerInfo.getLabel(), key -&gt; {</span>
<span class="fc" id="L318">                    return FieldAccessorUtils.getColumnPropertiesByName(</span>
<span class="fc" id="L319">                            record.getClass(), work.getAnnoReader(), config, key)</span>
<span class="fc" id="L320">                            .stream()</span>
<span class="fc" id="L321">                            .filter(p -&gt; p.isWritable())</span>
<span class="fc" id="L322">                            .collect(Collectors.toList());</span>
                });

<span class="fc bfc" id="L325" title="All 2 branches covered.">                for(FieldAccessor property : propeties) {</span>
<span class="fc" id="L326">                    Cell valueCell = cell;</span>
<span class="fc" id="L327">                    final XlsColumn column = property.getAnnotationNullable(XlsColumn.class);</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">                    if(column.headerMerged() &gt; 0){</span>
<span class="fc" id="L330">                        hRow = hRow + column.headerMerged();</span>
<span class="fc" id="L331">                        valueCell = POIUtils.getCell(sheet, hColumn, hRow);</span>
                    }

                    // for merged cell
<span class="fc bfc" id="L335" title="All 2 branches covered.">                    if(POIUtils.isEmptyCellContents(valueCell, config.getCellFormatter())){</span>
<span class="fc" id="L336">                        CellStyle valueCellFormat = valueCell.getCellStyle();</span>
<span class="fc bfc" id="L337" title="All 4 branches covered.">                        if(column.merged() &amp;&amp; POIUtils.getBorderRight(valueCell).equals(BorderStyle.NONE)){</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                            for(int k=hColumn; k &gt; initColumn; k--){</span>
<span class="fc" id="L339">                                final Cell tmpCell = POIUtils.getCell(sheet, k, hRow);</span>
<span class="fc" id="L340">                                final CellStyle tmpCellFormat = tmpCell.getCellStyle();</span>

<span class="fc bfc" id="L342" title="All 2 branches covered.">                                if(!POIUtils.getBorderLeft(tmpCell).equals(BorderStyle.NONE)){</span>
<span class="fc" id="L343">                                    break;</span>
                                }

<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                                if(!POIUtils.isEmptyCellContents(tmpCell, config.getCellFormatter())){</span>
<span class="nc" id="L347">                                    valueCell = tmpCell;</span>
<span class="nc" id="L348">                                    break;</span>
                                }
                            }
                        }
                    }

<span class="fc bfc" id="L354" title="All 2 branches covered.">                    if(column.headerMerged() &gt; 0){</span>
<span class="fc" id="L355">                        hRow = hRow - column.headerMerged();</span>
                    }

<span class="fc" id="L358">                    CellRangeAddress mergedRange = POIUtils.getMergedRegion(sheet, valueCell.getRowIndex(), valueCell.getColumnIndex());</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                    if(mergedRange != null) {</span>
<span class="fc" id="L360">                        int mergedSize =  mergedRange.getLastColumn() - mergedRange.getFirstColumn() + 1;</span>
<span class="fc" id="L361">                        mergedRecords.add(new MergedRecord(headerInfo, mergedRange, mergedSize));</span>
<span class="fc" id="L362">                    } else {</span>
<span class="fc" id="L363">                        mergedRecords.add(new MergedRecord(headerInfo, CellRangeAddress.valueOf(POIUtils.formatCellAddress(valueCell)), 1));</span>
                    }

<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                    if(!Utils.isLoadCase(column.cases())) {</span>
<span class="nc" id="L367">                        continue;</span>
                    }

                    // set for value
<span class="fc" id="L371">                    property.setPosition(record, CellPosition.of(valueCell));</span>
<span class="fc" id="L372">                    property.setLabel(record, headerInfo.getLabel());</span>

<span class="fc" id="L374">                    final Cell tempCommentCell = valueCell;</span>
<span class="fc" id="L375">                    property.getCommentSetter().ifPresent(setter -&gt; </span>
<span class="fc" id="L376">                            config.getCommentOperator().loadCellComment(setter, tempCommentCell, record, property, config));</span>
                    
<span class="fc" id="L378">                    final CellConverter&lt;?&gt; converter = converterCache.computeIfAbsent(property.getName(), key -&gt; getCellConverter(property, config));</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">                    if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L380">                        work.getErrors().registerFieldFormatter(property.getName(), property.getType(), (FieldFormatter&lt;?&gt;)converter, true);</span>
                    }

                    try {
<span class="fc" id="L384">                        final Object value = converter.toObject(valueCell);</span>
<span class="fc" id="L385">                        property.setValue(record, value);</span>
<span class="fc" id="L386">                    } catch(TypeBindException e) {</span>
<span class="fc" id="L387">                        work.addTypeBindError(e, valueCell, property.getName(), headerInfo.getLabel());</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">                        if(!config.isContinueTypeBindFailure()) {</span>
<span class="nc" id="L389">                            throw e;</span>
                        }
<span class="fc" id="L391">                    }</span>
<span class="fc" id="L392">                }</span>
            }

            // execute nested record
<span class="fc" id="L396">            final int skipSize = loadNestedRecords(sheet, headers, mergedRecords, anno, CellPosition.of(initRow, hColumn), record, config, work);</span>
<span class="pc bpc" id="L397" title="1 of 6 branches missed.">            if(parentMergedSize &gt; 0 &amp;&amp; skipSize &gt; 0 &amp;&amp; (hColumn + skipSize) &gt; maxColumn) {</span>
                // check over merged cell.
<span class="nc" id="L399">                String message = String.format(&quot;Over merged size. In sheet '%s' with columnIndex=%d, over the columnIndex=%s.&quot;,</span>
<span class="nc" id="L400">                        sheet.getSheetName(), hColumn + skipSize, maxColumn);</span>
<span class="nc" id="L401">                throw new NestedRecordMergedSizeException(sheet.getSheetName(), skipSize, message);</span>
            }


<span class="fc bfc" id="L405" title="All 2 branches covered.">            if(emptyFlag){</span>
                // パスの位置の変更
<span class="fc" id="L407">                work.getErrors().popNestedPath();</span>
<span class="fc" id="L408">                break;</span>
            }

<span class="fc bfc" id="L411" title="All 2 branches covered.">            if(isAvailabledRecord(methodCache.getIgnoreableMethod(), record)) {</span>
                // 有効なレコードのみ、処理を行う
<span class="fc" id="L413">                result.add(record);</span>

                // set PostProcess listener
<span class="fc" id="L416">                methodCache.getListenerClasses().forEach(listenerClass -&gt; {</span>
<span class="fc" id="L417">                    listenerClass.getPostLoadMethods().forEach(method -&gt; {</span>
<span class="fc" id="L418">                        work.addNeedPostProcess(new NeedProcess(record, listenerClass.getObject(), method));</span>
<span class="fc" id="L419">                    });</span>
<span class="fc" id="L420">                });</span>

                // set PostProcess method
<span class="fc" id="L423">                methodCache.getPostLoadMethods().forEach(method -&gt; {</span>
<span class="fc" id="L424">                    work.addNeedPostProcess(new NeedProcess(record, record, method));</span>
<span class="fc" id="L425">                });</span>

            }

            // パスの位置の変更
<span class="fc" id="L430">            work.getErrors().popNestedPath();</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">            if(skipSize &gt; 0) {</span>
<span class="fc" id="L433">                hColumn += skipSize;</span>
            } else {
<span class="fc" id="L435">                hColumn++;</span>
            }

<span class="fc" id="L438">        }</span>

<span class="fc" id="L440">        return result;</span>
    }

    /**
     * 表の開始位置（見出し）の位置情報を取得する。
     *
     * @param sheet
     * @param anno
     * @param accessor
     * @param config
     * @return 表の開始位置。指定したラベルが見つからない場合、設定によりnullを返す。
     * @throws AnnotationInvalidException アノテーションの値が不正で、表の開始位置が位置が見つからない場合。
     * @throws CellNotFoundException 指定したラベルが見つからない場合。
     */
    private Optional&lt;CellPosition&gt; getHeaderPosition(final Sheet sheet, final XlsVerticalRecords anno,
            final FieldAccessor accessor, final Configuration config) throws AnnotationInvalidException, CellNotFoundException {

<span class="fc bfc" id="L457" title="All 2 branches covered.">        if(Utils.isNotEmpty(anno.headerAddress())) {</span>
            try {
<span class="fc" id="L459">                return Optional.of(CellPosition.of(anno.headerAddress()));</span>

<span class="fc" id="L461">            } catch(IllegalArgumentException e) {</span>
<span class="fc" id="L462">                throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.invalidAddress&quot;)</span>
<span class="fc" id="L463">                        .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="fc" id="L464">                        .varWithAnno(&quot;anno&quot;, XlsVerticalRecords.class)</span>
<span class="fc" id="L465">                        .var(&quot;attrName&quot;, &quot;headerAddress&quot;)</span>
<span class="fc" id="L466">                        .var(&quot;attrValue&quot;, anno.headerAddress())</span>
<span class="fc" id="L467">                        .format());</span>

            }

<span class="fc bfc" id="L471" title="All 2 branches covered.">        } else if(Utils.isNotEmpty(anno.tableLabel())) {</span>
            try {
<span class="fc" id="L473">                final Cell labelCell = CellFinder.query(sheet, anno.tableLabel(), config).findWhenNotFoundException();</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">                if(anno.tableLabelAbove()) {</span>
                    // 表の見出しが上にある場合、左側に補正する
<span class="fc" id="L477">                    int initColumn = labelCell.getColumnIndex() + anno.right()-1;</span>
<span class="fc" id="L478">                    int initRow = labelCell.getRowIndex() + anno.bottom();</span>
<span class="fc" id="L479">                    return Optional.of(CellPosition.of(initRow, initColumn));</span>

                } else {

<span class="fc" id="L483">                    int initColumn = labelCell.getColumnIndex() + anno.right();</span>
<span class="fc" id="L484">                    int initRow = labelCell.getRowIndex();</span>
<span class="fc" id="L485">                    return Optional.of(CellPosition.of(initRow, initColumn));</span>

                }

<span class="fc" id="L489">            } catch(CellNotFoundException ex) {</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                if(anno.optional()) {</span>
<span class="fc" id="L491">                    return Optional.empty();</span>
                } else {
<span class="fc" id="L493">                    throw ex;</span>
                }
            }
        } else {
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if(anno.headerRow() &lt; 0) {</span>
<span class="fc" id="L498">                throw  new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.min&quot;)</span>
<span class="fc" id="L499">                        .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="fc" id="L500">                        .varWithAnno(&quot;anno&quot;, XlsVerticalRecords.class)</span>
<span class="fc" id="L501">                        .var(&quot;attrName&quot;, &quot;headerRow&quot;)</span>
<span class="fc" id="L502">                        .var(&quot;attrValue&quot;, anno.headerRow())</span>
<span class="fc" id="L503">                        .var(&quot;min&quot;, 0)</span>
<span class="fc" id="L504">                        .format());</span>
            }

<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            if(anno.headerColumn() &lt; 0) {</span>
<span class="nc" id="L508">                throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.min&quot;)</span>
<span class="nc" id="L509">                        .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="nc" id="L510">                        .varWithAnno(&quot;anno&quot;, XlsVerticalRecords.class)</span>
<span class="nc" id="L511">                        .var(&quot;attrName&quot;, &quot;column&quot;)</span>
<span class="nc" id="L512">                        .var(&quot;attrValue&quot;, anno.headerColumn())</span>
<span class="nc" id="L513">                        .var(&quot;min&quot;, 0)</span>
<span class="nc" id="L514">                        .format());</span>

            }
<span class="fc" id="L517">            return Optional.of(CellPosition.of(anno.headerRow(), anno.headerColumn()));</span>
        }
    }

    /**
     * 表の見出しから、レコードのJavaクラスの定義にあるカラムの定義で初めて見つかるリストのインデックスを取得する。
     * &lt;p&gt;カラムの定義とは、アノテーション「@XlsColumn」が付与されたもの。
     * @param headers 表の見出し情報。
     * @param recordClass アノテーション「@XlsColumn」が定義されたフィールドを持つレコード用のクラス。
     * @param annoReader {@link AnnotationReader}
     * @param config システム設定
     * @return 引数「headers」の該当する要素のインデックス番号。不明な場合は0を返す。
     */
    private int getStartHeaderIndexForLoading(final List&lt;RecordHeader&gt; headers, Class&lt;?&gt; recordClass,
            final AnnotationReader annoReader,  final Configuration config) {

        // レコードクラスが不明の場合、0を返す。
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">        if((recordClass == null || recordClass.equals(Object.class))) {</span>
<span class="nc" id="L535">            return 0;</span>
        }

<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        for(int i=0; i &lt; headers.size(); i++) {</span>
<span class="fc" id="L539">            RecordHeader headerInfo = headers.get(i);</span>
<span class="fc" id="L540">            final List&lt;FieldAccessor&gt; propeties = FieldAccessorUtils.getColumnPropertiesByName(</span>
<span class="fc" id="L541">                    recordClass, annoReader, config, headerInfo.getLabel())</span>
<span class="fc" id="L542">                    .stream()</span>
<span class="fc" id="L543">                    .filter(p -&gt; p.isWritable())</span>
<span class="fc" id="L544">                    .collect(Collectors.toList());</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            if(!propeties.isEmpty()) {</span>
<span class="fc" id="L546">                return i;</span>
            }
        }

<span class="nc" id="L550">        return 0;</span>

    }

    private void loadMapColumns(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;MergedRecord&gt; mergedRecords,
            final CellPosition beginPosition, final Class&lt;?&gt; recordClass, final Object record, final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

<span class="fc" id="L557">        final List&lt;FieldAccessor&gt; properties = FieldAccessorUtils.getPropertiesWithAnnotation(</span>
<span class="fc" id="L558">                recordClass, work.getAnnoReader(), XlsMapColumns.class)</span>
<span class="fc" id="L559">                .stream()</span>
<span class="fc" id="L560">                .filter(p -&gt; p.isWritable())</span>
<span class="fc" id="L561">                .collect(Collectors.toList());</span>

<span class="fc bfc" id="L563" title="All 2 branches covered.">        for(FieldAccessor property : properties) {</span>
<span class="fc" id="L564">            final XlsMapColumns mapAnno = property.getAnnotationNullable(XlsMapColumns.class);</span>

<span class="pc bpc" id="L566" title="1 of 2 branches missed.">            if(!Utils.isLoadCase(mapAnno.cases())) {</span>
<span class="nc" id="L567">                continue;</span>
            }

<span class="fc" id="L570">            Class&lt;?&gt; valueClass = mapAnno.valueClass();</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">            if(valueClass == Object.class) {</span>
<span class="fc" id="L572">                valueClass = property.getComponentType();</span>
            }

            // get converter (map key class)
<span class="fc" id="L576">            final CellConverter&lt;?&gt; converter = getCellConverter(valueClass, property, config);</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">            if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L578">                work.getErrors().registerFieldFormatter(property.getName(), valueClass, (FieldFormatter&lt;?&gt;)converter, true);</span>
            }

<span class="fc" id="L581">            boolean foundPreviousColumn = false;</span>
<span class="fc" id="L582">            final Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            for(RecordHeader headerInfo : headers){</span>
<span class="fc" id="L584">                int hRow = beginPosition.getRow() + headerInfo.getInterval();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                if(Utils.matches(headerInfo.getLabel(), mapAnno.previousColumnName(), config)){</span>
<span class="fc" id="L586">                    foundPreviousColumn = true;</span>
<span class="fc" id="L587">                    hRow++;</span>
<span class="fc" id="L588">                    continue;</span>
                }

<span class="fc bfc" id="L591" title="All 4 branches covered.">                if(Utils.isNotEmpty(mapAnno.nextColumnName()) &amp;&amp; Utils.matches(headerInfo.getLabel(), mapAnno.nextColumnName(), config)) {</span>
<span class="fc" id="L592">                    break;</span>
                }

<span class="fc bfc" id="L595" title="All 2 branches covered.">                if(foundPreviousColumn){</span>
<span class="fc" id="L596">                    final Cell cell = POIUtils.getCell(sheet, beginPosition.getColumn(), hRow);</span>
<span class="fc" id="L597">                    property.setMapPosition(record, CellPosition.of(cell), headerInfo.getLabel());</span>
<span class="fc" id="L598">                    property.setMapLabel(record, headerInfo.getLabel(), headerInfo.getLabel());</span>

<span class="fc" id="L600">                    property.getMapCommentSetter().ifPresent(setter -&gt; </span>
<span class="fc" id="L601">                    config.getCommentOperator().loadMapCellComment(setter, cell, record, headerInfo.getLabel(), property, config));</span>
                    
<span class="fc" id="L603">                    CellRangeAddress mergedRange = POIUtils.getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">                    if(mergedRange != null) {</span>
<span class="nc" id="L605">                        int mergedSize =  mergedRange.getLastColumn() - mergedRange.getFirstColumn() + 1;</span>
<span class="nc" id="L606">                        mergedRecords.add(new MergedRecord(headerInfo, mergedRange, mergedSize));</span>
<span class="nc" id="L607">                    } else {</span>
<span class="fc" id="L608">                        mergedRecords.add(new MergedRecord(headerInfo, CellRangeAddress.valueOf(POIUtils.formatCellAddress(cell)), 1));</span>
                    }

                    try {
<span class="fc" id="L612">                        final Object value = converter.toObject(cell);</span>
<span class="fc" id="L613">                        map.put(headerInfo.getLabel(), value);</span>
<span class="fc" id="L614">                    } catch(TypeBindException e) {</span>
<span class="fc" id="L615">                        e.setBindClass(valueClass);  // マップの項目のタイプに変更</span>
<span class="fc" id="L616">                        work.addTypeBindError(e, cell, String.format(&quot;%s[%s]&quot;, property.getName(), headerInfo.getLabel()), headerInfo.getLabel());</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                        if(!config.isContinueTypeBindFailure()) {</span>
<span class="fc" id="L618">                            throw e;</span>
                        }
<span class="fc" id="L620">                    }</span>
                }
<span class="fc" id="L622">            }</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">            if(foundPreviousColumn) {</span>
<span class="fc" id="L625">                property.setValue(record, map);</span>
            }
<span class="fc" id="L627">        }</span>
<span class="fc" id="L628">    }</span>

    private void loadArrayColumns(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;MergedRecord&gt; mergedRecords,
            final CellPosition beginPosition, final Class&lt;?&gt; recordClass, final Object record, final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

<span class="fc bfc" id="L633" title="All 2 branches covered.">        for(RecordHeader headerInfo : headers) {</span>
<span class="fc" id="L634">            int hRow = beginPosition.getRow() + headerInfo.getInterval();</span>

            // アノテーション「@XlsArrayColumns」の属性「columnName」と一致するプロパティを取得する。
<span class="fc" id="L637">            final List&lt;FieldAccessor&gt; arrayProperties = FieldAccessorUtils.getArrayColumnsPropertiesByName(</span>
<span class="fc" id="L638">                    recordClass, work.getAnnoReader(), config, headerInfo.getLabel())</span>
<span class="fc" id="L639">                    .stream()</span>
<span class="fc" id="L640">                    .filter(f -&gt; f.isWritable())</span>
<span class="fc" id="L641">                    .collect(Collectors.toList());</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">            if(arrayProperties.isEmpty()) {</span>
<span class="fc" id="L644">                continue;</span>
            }

<span class="fc bfc" id="L647" title="All 2 branches covered.">            for(FieldAccessor property : arrayProperties) {</span>

<span class="fc" id="L649">                final XlsArrayColumns arrayAnno = property.getAnnotationNullable(XlsArrayColumns.class);</span>

<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                if(!Utils.isLoadCase(arrayAnno.cases())) {</span>
<span class="nc" id="L652">                    continue;</span>
                }
<span class="fc" id="L654">                Class&lt;?&gt; elementClass = arrayAnno.elementClass();</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                if(elementClass == Object.class) {</span>
<span class="fc" id="L656">                    elementClass = property.getComponentType();</span>
                }

                // get converter (component class)
<span class="fc" id="L660">                final CellConverter&lt;?&gt; converter = getCellConverter(elementClass, property, config);</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">                if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L662">                    work.getErrors().registerFieldFormatter(property.getName(), elementClass, (FieldFormatter&lt;?&gt;)converter, true);</span>
                }

<span class="fc" id="L665">                final CellPosition initPosition = CellPosition.of(hRow, beginPosition.getColumn());</span>

<span class="fc" id="L667">                ArrayCellsHandler arrayHandler = new ArrayCellsHandler(property, record, elementClass, sheet, config);</span>
<span class="fc" id="L668">                arrayHandler.setLabel(headerInfo.getLabel());</span>

<span class="fc" id="L670">                final List&lt;Object&gt; result = arrayHandler.handleOnLoading(arrayAnno, initPosition, converter, work, ArrayDirection.Vertical);</span>

<span class="pc bpc" id="L672" title="1 of 2 branches missed.">                if(result != null) {</span>
                    // インデックスが付いていないラベルの設定
<span class="fc" id="L674">                    property.setLabel(record, headerInfo.getLabel());</span>
                }

<span class="fc" id="L677">                final Class&lt;?&gt; propertyType = property.getType();</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                if(Collection.class.isAssignableFrom(propertyType)) {</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                    if(result != null) {</span>
                        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<span class="fc" id="L681">                        Collection&lt;?&gt; collection = Utils.convertListToCollection(result, (Class&lt;Collection&gt;)propertyType, config.getBeanFactory());</span>
<span class="fc" id="L682">                        property.setValue(record, collection);</span>
<span class="fc" id="L683">                    }</span>

<span class="nc bnc" id="L685" title="All 2 branches missed.">                } else if(propertyType.isArray()) {</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">                    if(result != null) {</span>
<span class="nc" id="L688">                        final Object array = Array.newInstance(elementClass, result.size());</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">                        for(int i=0; i &lt; result.size(); i++) {</span>
<span class="nc" id="L690">                            Array.set(array, i, result.get(i));</span>
                        }
<span class="nc" id="L692">                        property.setValue(record, array);</span>
<span class="nc" id="L693">                    }</span>

                } else {
<span class="nc" id="L696">                    throw new AnnotationInvalidException(arrayAnno, MessageBuilder.create(&quot;anno.notSupportType&quot;)</span>
<span class="nc" id="L697">                            .var(&quot;property&quot;, property.getNameWithClass())</span>
<span class="nc" id="L698">                            .varWithAnno(&quot;anno&quot;, XlsArrayColumns.class)</span>
<span class="nc" id="L699">                            .varWithClass(&quot;actualType&quot;, propertyType)</span>
<span class="nc" id="L700">                            .var(&quot;expectedType&quot;, &quot;Collection(List/Set) or Array&quot;)</span>
<span class="nc" id="L701">                            .format());</span>
                }
<span class="fc" id="L703">            }</span>
<span class="fc" id="L704">        }</span>

<span class="fc" id="L706">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private int loadNestedRecords(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;MergedRecord&gt; mergedRecords,
            final XlsVerticalRecords anno,
            final CellPosition beginPosition,
            final Object record,
            final Configuration config, final LoadingWorkObject work) throws XlsMapperException {

        // 読み飛ばす、レコード数。
        // 基本的に結合している個数による。
<span class="fc" id="L717">        int skipSize = 0;</span>

<span class="fc" id="L719">        final List&lt;FieldAccessor&gt; nestedProperties = FieldAccessorUtils.getPropertiesWithAnnotation(</span>
<span class="fc" id="L720">                record.getClass(), work.getAnnoReader(), XlsNestedRecords.class)</span>
<span class="fc" id="L721">                .stream()</span>
<span class="fc" id="L722">                .filter(p -&gt; p.isWritable())</span>
<span class="fc" id="L723">                .collect(Collectors.toList());</span>
        
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for(FieldAccessor property : nestedProperties) {</span>

<span class="fc" id="L727">            final XlsNestedRecords nestedAnno = property.getAnnotationNullable(XlsNestedRecords.class);</span>

<span class="pc bpc" id="L729" title="1 of 2 branches missed.">            if(!Utils.isLoadCase(nestedAnno.cases())) {</span>
<span class="nc" id="L730">                continue;</span>
            }

<span class="fc" id="L733">            final Class&lt;?&gt; clazz = property.getType();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if(Collection.class.isAssignableFrom(clazz)) {</span>
                // mapping by one-to-many

<span class="fc" id="L737">                int mergedSize = RecordsProcessorUtil.checkNestedMergedSizeRecords(sheet, mergedRecords);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">                if(skipSize &lt; mergedSize) {</span>
<span class="fc" id="L739">                    skipSize = mergedSize;</span>
                }

<span class="fc" id="L742">                Class&lt;?&gt; recordClass = nestedAnno.recordClass();</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L744">                    recordClass = property.getComponentType();</span>
                }

<span class="fc" id="L747">                List&lt;?&gt; value = loadRecords(sheet, headers, anno, beginPosition, mergedSize, property, recordClass, config, work);</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">                if(value != null) {</span>
<span class="fc" id="L749">                    Collection&lt;?&gt; collection = Utils.convertListToCollection(value, (Class&lt;Collection&gt;)clazz, config.getBeanFactory());</span>
<span class="fc" id="L750">                    property.setValue(record, collection);</span>
                }

<span class="fc bfc" id="L753" title="All 2 branches covered.">            } else if(clazz.isArray()) {</span>
                // mapping by one-to-many

<span class="fc" id="L756">                int mergedSize = RecordsProcessorUtil.checkNestedMergedSizeRecords(sheet, mergedRecords);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                if(skipSize &lt; mergedSize) {</span>
<span class="fc" id="L758">                    skipSize = mergedSize;</span>
                }

<span class="fc" id="L761">                Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L763">                    recordClass = property.getComponentType();</span>
                }

<span class="fc" id="L766">                List&lt;?&gt; value = loadRecords(sheet, headers, anno, beginPosition, mergedSize, property, recordClass, config, work);</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">                if(value != null) {</span>
<span class="fc" id="L768">                    final Object array = Array.newInstance(recordClass, value.size());</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">                    for(int i=0; i &lt; value.size(); i++) {</span>
<span class="fc" id="L770">                        Array.set(array, i, value.get(i));</span>
                    }

<span class="fc" id="L773">                    property.setValue(record, array);</span>
                }

<span class="fc" id="L776">            } else {</span>
                // mapping by one-to-tone

<span class="fc" id="L779">                int mergedSize = 1;</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">                if(skipSize &lt; mergedSize) {</span>
<span class="fc" id="L781">                    skipSize = mergedSize;</span>
                }

<span class="fc" id="L784">                Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L786">                    recordClass = property.getType();</span>
                }

<span class="fc" id="L789">                List&lt;?&gt; value = loadRecords(sheet, headers, anno, beginPosition, mergedSize, property, recordClass, config, work);</span>
<span class="pc bpc" id="L790" title="1 of 4 branches missed.">                if(value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L791">                    property.setValue(record, value.get(0));</span>
                }

            }
<span class="fc" id="L795">        }</span>

<span class="fc" id="L797">        return skipSize;</span>
    }

    /**
     * レコードが有効かどうか判定する
     * &lt;p&gt;アノテーション{@link XlsIgnorable}のメソッドで判定を行う。
     * @param ignoreMethod レコードの判定を無視するかどうかの判定に使用するメソッド
     * @param record 判定対象のレコードのインスタンス。
     * @return trueの場合は有効。
     */
    private boolean isAvailabledRecord(final Optional&lt;Method&gt; ignoreMethod, final Object record)
            throws AnnotationReadException, AnnotationInvalidException {

<span class="fc bfc" id="L810" title="All 2 branches covered.">        if(!ignoreMethod.isPresent()) {</span>
            // 判定用のメソッドが存在しない場合
<span class="fc" id="L812">            return true;</span>
        }

        try {
<span class="fc" id="L816">            boolean ignored = (boolean)ignoreMethod.get().invoke(record);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">            return !ignored;</span>

<span class="nc" id="L819">        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L820">            throw new RuntimeException(&quot;fail execute method of ignoreable record&quot;, e);</span>
        }

    }

    @Override
    public void saveProcess(final Sheet sheet, final Object beansObj, final XlsVerticalRecords anno,
            final FieldAccessor accessor, final Configuration config, final SavingWorkObject work) throws XlsMapperException {

<span class="fc bfc" id="L829" title="All 2 branches covered.">        if(!accessor.isReadable()) {</span>
            // セルの値を参照するメソッド／フィールドがない場合はスキップ
<span class="fc" id="L831">            return;</span>
        }
        
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if(!Utils.isSaveCase(anno.cases())) {</span>
<span class="nc" id="L835">            return;</span>
        }

<span class="fc" id="L838">        final Class&lt;?&gt; clazz = accessor.getType();</span>
<span class="fc" id="L839">        final Object result = accessor.getValue(beansObj);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">        if(Collection.class.isAssignableFrom(clazz)) {</span>

<span class="fc" id="L842">            Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">            if(recordClass == Object.class) {</span>
<span class="fc" id="L844">                recordClass = accessor.getComponentType();</span>
            }

<span class="fc bfc" id="L847" title="All 2 branches covered.">            final Collection&lt;Object&gt; value = (result == null ? new ArrayList&lt;Object&gt;() : (Collection&lt;Object&gt;) result);</span>
<span class="fc" id="L848">            final List&lt;Object&gt; list = Utils.convertCollectionToList(value);</span>
<span class="fc" id="L849">            saveRecords(sheet, beansObj, anno, accessor, recordClass, list, config, work);</span>

<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        } else if(clazz.isArray()) {</span>

<span class="fc" id="L853">            Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">            if(recordClass == Object.class) {</span>
<span class="fc" id="L855">                recordClass = accessor.getComponentType();</span>
            }

<span class="fc" id="L858">            final List&lt;Object&gt; list = Utils.asList(result, recordClass);</span>
<span class="fc" id="L859">            saveRecords(sheet, beansObj, anno, accessor, recordClass, list, config, work);</span>

<span class="fc" id="L861">        } else {</span>
<span class="nc" id="L862">            throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.notSupportType&quot;)</span>
<span class="nc" id="L863">                    .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="nc" id="L864">                    .varWithAnno(&quot;anno&quot;, XlsVerticalRecords.class)</span>
<span class="nc" id="L865">                    .varWithClass(&quot;actualType&quot;, clazz)</span>
<span class="nc" id="L866">                    .var(&quot;expectedType&quot;, &quot;Collection(List/Set) or Array&quot;)</span>
<span class="nc" id="L867">                    .format());</span>
        }

<span class="fc" id="L870">    }</span>

    private void saveRecords(final Sheet sheet, final Object beansObj, final XlsVerticalRecords anno, final FieldAccessor accessor,
            final Class&lt;?&gt; recordClass, final List&lt;Object&gt; result,
            final Configuration config, final SavingWorkObject work) throws XlsMapperException {

<span class="fc" id="L876">        RecordsProcessorUtil.checkSavingNestedRecordClass(recordClass, accessor, work.getAnnoReader());</span>

        // get table starting position
<span class="fc" id="L879">        final Optional&lt;CellPosition&gt; initPosition = getHeaderPosition(sheet, anno, accessor, config);</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if(!initPosition.isPresent()) {</span>
<span class="fc" id="L881">            return;</span>
        }

        // ラベルの設定
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if(Utils.isNotEmpty(anno.tableLabel())) {</span>
<span class="fc" id="L886">            final Optional&lt;Cell&gt; tableLabelCell = CellFinder.query(sheet, anno.tableLabel(), config).findOptional();</span>
<span class="fc" id="L887">            tableLabelCell.ifPresent(c -&gt; {</span>
<span class="fc" id="L888">                final String label = POIUtils.getCellContents(c, config.getCellFormatter());</span>
<span class="fc" id="L889">                accessor.setLabel(beansObj, label);</span>

<span class="fc" id="L891">            });</span>
        }

<span class="fc" id="L894">        final int initColumn = initPosition.get().getColumn();</span>
<span class="fc" id="L895">        final int initRow = initPosition.get().getRow();</span>

<span class="fc" id="L897">        int hColumn = initColumn;</span>
<span class="fc" id="L898">        int hRow = initRow;</span>

        // get header columns.
<span class="fc" id="L901">        final List&lt;RecordHeader&gt; headers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L902">        int rangeCount = 1;</span>
        while(true) {
            try {
<span class="fc" id="L905">                Cell cell = POIUtils.getCell(sheet, hColumn, hRow);</span>
<span class="fc bfc" id="L906" title="All 4 branches covered.">                while(POIUtils.isEmptyCellContents(cell, config.getCellFormatter()) &amp;&amp; rangeCount &lt; anno.range()) {</span>
<span class="fc" id="L907">                    cell = POIUtils.getCell(sheet, hColumn, hRow + rangeCount);</span>
<span class="fc" id="L908">                    rangeCount++;</span>
                }

<span class="fc" id="L911">                final String cellValue = POIUtils.getCellContents(cell, config.getCellFormatter());</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">                if(Utils.isEmpty(cellValue)) {</span>
<span class="fc" id="L913">                    break;</span>
                }

<span class="fc" id="L916">                headers.add(new RecordHeader(cellValue, cell.getRowIndex() - initRow));</span>
<span class="fc" id="L917">                hRow = hRow + rangeCount;</span>
<span class="fc" id="L918">                rangeCount = 1;</span>

                // 結合しているセルの場合は、はじめのセルだけ取得して、後は結合分スキップする。
<span class="fc" id="L921">                CellRangeAddress mergedRange = POIUtils.getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                if(mergedRange != null) {</span>
<span class="fc" id="L923">                    hRow = hRow + (mergedRange.getLastRow() - mergedRange.getFirstRow());</span>
                }

<span class="nc" id="L926">            } catch(ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L927">                break;</span>
<span class="fc" id="L928">            }</span>

<span class="fc bfc" id="L930" title="All 4 branches covered.">            if(anno.headerLimit() &gt; 0 &amp;&amp; headers.size() &gt;= anno.headerLimit()){</span>
<span class="fc" id="L931">                break;</span>
            }
        }

        // レコードの操作のアノテーション
<span class="fc" id="L936">        final XlsRecordOption recordOptionAnno = getRecordOptionAnnotation(accessor);</span>

        // データ行の開始位置の調整
<span class="fc" id="L939">        hColumn += anno.headerRight();</span>
<span class="fc" id="L940">        CellPosition startPosition = CellPosition.of(initRow, hColumn);</span>

        // 独自の開始位置を指定する場合
<span class="fc" id="L943">        final Optional&lt;XlsRecordFinder&gt; finderAnno = accessor.getAnnotation(XlsRecordFinder.class);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if(finderAnno.isPresent()) {</span>
<span class="fc" id="L945">            final RecordFinder finder = config.createBean(finderAnno.get().value());</span>
<span class="fc" id="L946">            startPosition = finder.find(ProcessCase.Save, finderAnno.get().args(), sheet, startPosition, beansObj, config);</span>

        }

        // 書き込んだセルの範囲などの情報
<span class="fc" id="L951">        final RecordOperation recordOperation = new RecordOperation(recordOptionAnno);</span>
<span class="fc" id="L952">        recordOperation.setupCellPositoin(startPosition);</span>

        // XlsColumn(merged=true)の結合したセルの情報
<span class="fc" id="L955">        final List&lt;CellRangeAddress&gt; mergedRanges = new ArrayList&lt;CellRangeAddress&gt;();</span>

<span class="fc" id="L957">        saveRecords(sheet, headers,</span>
                anno,
                startPosition, new AtomicInteger(0),
                accessor, recordClass, result,
                config, work,
                mergedRanges, recordOperation);

        // 書き込むデータがない場合は、1行目の終端を操作範囲とする。
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if(result.isEmpty()) {</span>
<span class="fc" id="L966">            recordOperation.setupCellPositoin(hRow-1, startPosition.getColumn());</span>
        }

<span class="fc bfc" id="L969" title="All 2 branches covered.">        if(config.isCorrectCellDataValidationOnSave()) {</span>
<span class="fc" id="L970">            correctDataValidation(sheet, recordOperation);</span>
        }

<span class="fc bfc" id="L973" title="All 2 branches covered.">        if(config.isCorrectNameRangeOnSave()) {</span>
<span class="fc" id="L974">            correctNameRange(sheet, recordOperation);</span>
        }
<span class="fc" id="L976">    }</span>

    /**
     * アノテーション{@link XlsRecordOption}を取得する。
     * ただし、付与されていない場合は、属性にデフォルト値が指定されているものを取得する。
     * @param accessor フィールド情報
     * @return アノテーションのインスタンス
     */
    private XlsRecordOption getRecordOptionAnnotation(final FieldAccessor accessor) {

<span class="fc" id="L986">        return accessor.getAnnotation(XlsRecordOption.class)</span>
<span class="fc" id="L987">                .orElseGet(() -&gt; new XlsRecordOption() {</span>

                    @Override
                    public Class&lt;? extends Annotation&gt; annotationType() {
<span class="nc" id="L991">                        return XlsRecordOption.class;</span>
                    }

                    @Override
                    public RemainedOperation remainedOperation() {
<span class="fc" id="L996">                        return RemainedOperation.None;</span>
                    }

                    @Override
                    public OverOperation overOperation() {
<span class="nc" id="L1001">                        return OverOperation.Break;</span>
                    }
                });


    }

    private void saveRecords(final Sheet sheet, final List&lt;RecordHeader&gt; headers,
            final XlsVerticalRecords anno,
            final CellPosition initPosition, final AtomicInteger nestedRecordSize,
            final FieldAccessor accessor, final Class&lt;?&gt; recordClass, final List&lt;Object&gt; result,
            final Configuration config, final SavingWorkObject work,
            final List&lt;CellRangeAddress&gt; mergedRanges, final RecordOperation recordOperation) throws XlsMapperException {

<span class="fc" id="L1015">        final int initColumn = initPosition.getColumn();</span>
<span class="fc" id="L1016">        final int initRow = initPosition.getRow();</span>

<span class="fc" id="L1018">        int hColumn = initColumn;</span>

        // Check for columns
<span class="fc" id="L1021">        RecordsProcessorUtil.checkColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>
<span class="fc" id="L1022">        RecordsProcessorUtil.checkMapColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>
<span class="fc" id="L1023">        RecordsProcessorUtil.checkArrayColumns(sheet, recordClass, headers, work.getAnnoReader(), config);</span>

        /*
         * 書き込む時には終了位置の判定は、Borderで固定する必要がある。
         * ・Emptyの場合だと、テンプレート用のシートなので必ずデータ用のセルが、空なので書き込まれなくなる。
         * ・Emptyの場合、Borderに補正して書き込む。
         */
<span class="fc" id="L1030">        RecordTerminal terminal = anno.terminal();</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        if(terminal == RecordTerminal.Empty) {</span>
<span class="fc" id="L1032">            terminal = RecordTerminal.Border;</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">        } else if(terminal == null){</span>
<span class="nc" id="L1034">            terminal = RecordTerminal.Border;</span>
        }

        // 各種レコードのコールバック用メソッドを抽出する
<span class="fc" id="L1038">        final RecordMethodCache methodCache = new RecordMethodFacatory(work.getAnnoReader(), config)</span>
<span class="fc" id="L1039">                .create(recordClass, ProcessCase.Save);</span>

        // レコードの見出しに対するカラム情報のキャッシュ
<span class="fc" id="L1042">        final Map&lt;String, List&lt;FieldAccessor&gt;&gt; propertiesCache = new HashMap&lt;&gt;();</span>

        // カラムに対するConverterのキャッシュ
<span class="fc" id="L1045">        final Map&lt;String, CellConverter&lt;?&gt;&gt; converterCache = new HashMap&lt;&gt;();</span>

<span class="fc" id="L1047">        final int startHeaderIndex = getStartHeaderIndexForSaving(headers, recordClass, work.getAnnoReader(), config);</span>

        // get records
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        for(int r=0; r &lt; POIUtils.getColumns(sheet); r++) {</span>

<span class="fc" id="L1052">            boolean emptyFlag = true;</span>

            // 書き込むレコードのオブジェクトを取得。データが0件の場合、nullとなる。
            final Object record;
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            if(r &lt; result.size()) {</span>
<span class="fc" id="L1057">                record = result.get(r);</span>
            } else {
<span class="fc" id="L1059">                record = null;</span>
            }

            // パスの位置の変更
<span class="fc" id="L1063">            work.getErrors().pushNestedPath(accessor.getName(), r);</span>

<span class="fc bfc" id="L1065" title="All 2 branches covered.">            if(record != null) {</span>

                // execute PreProcess listner
<span class="fc" id="L1068">                methodCache.getListenerClasses().forEach(listenerClass -&gt; {</span>
<span class="fc" id="L1069">                    listenerClass.getPreSaveMethods().forEach(method -&gt; {</span>
<span class="fc" id="L1070">                        Utils.invokeNeedProcessMethod(listenerClass.getObject(), method, record, sheet, config, work.getErrors(), ProcessCase.Save);</span>
<span class="fc" id="L1071">                    });</span>
<span class="fc" id="L1072">                });</span>

                // execute PreProcess method
<span class="fc" id="L1075">                methodCache.getPreSaveMethods().forEach(method -&gt; {</span>
<span class="fc" id="L1076">                    Utils.invokeNeedProcessMethod(record, method, record, sheet, config, work.getErrors(), ProcessCase.Save);</span>
<span class="fc" id="L1077">                });</span>

            }

//            // レコードの各列処理で既に行を追加したかどうかのフラグ。
//            boolean insertRows = false;

//            // レコードの各列処理で既に行を削除したかどうかのフラグ。
//            boolean deleteRows = false;


            // 書き込んだセルの座標
            // ネストしたときに、結合するための情報として使用する。
<span class="fc" id="L1090">            List&lt;CellPosition&gt; valueCellPositions = new ArrayList&lt;&gt;();</span>

            // hRowという上限がない
<span class="fc bfc" id="L1093" title="All 2 branches covered.">            for(int i=0; i &lt; headers.size(); i++) {</span>
<span class="fc" id="L1094">                final RecordHeader headerInfo = headers.get(i);</span>
<span class="fc" id="L1095">                int hRow = initRow + headerInfo.getInterval();</span>
<span class="fc" id="L1096">                final Cell cell = POIUtils.getCell(sheet, hColumn, hRow);</span>

                // find end of the table
<span class="fc bfc" id="L1099" title="All 2 branches covered.">                if(!POIUtils.getCellContents(cell, config.getCellFormatter()).equals(&quot;&quot;)){</span>
<span class="fc" id="L1100">                    emptyFlag = false;</span>
                }

<span class="pc bpc" id="L1103" title="1 of 4 branches missed.">                if(terminal == RecordTerminal.Border &amp;&amp; i == startHeaderIndex){</span>
<span class="fc" id="L1104">                    final CellStyle format = cell.getCellStyle();</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">                    if(!POIUtils.getBorderTop(cell).equals(BorderStyle.NONE)){</span>
<span class="fc" id="L1106">                        emptyFlag = false;</span>
                    } else {
<span class="fc" id="L1108">                        emptyFlag = true;</span>
//                            break;
                    }
                }

<span class="fc bfc" id="L1113" title="All 2 branches covered.">                if(!anno.terminateLabel().equals(&quot;&quot;)){</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">                    if(Utils.matches(POIUtils.getCellContents(cell, config.getCellFormatter()), anno.terminateLabel(), config)){</span>
<span class="fc" id="L1115">                        emptyFlag = true;</span>
//                            break;
                    }
                }

                // mapping from Excel columns to Object properties.
<span class="fc bfc" id="L1121" title="All 2 branches covered.">                if(record != null) {</span>
<span class="fc" id="L1122">                    final List&lt;FieldAccessor&gt; propeties = propertiesCache.computeIfAbsent(headerInfo.getLabel(), key -&gt; {</span>
<span class="fc" id="L1123">                        return FieldAccessorUtils.getColumnPropertiesByName(</span>
<span class="fc" id="L1124">                                record.getClass(), work.getAnnoReader(), config, key)</span>
<span class="fc" id="L1125">                                .stream()</span>
<span class="fc" id="L1126">                                .filter(p -&gt; p.isReadable())</span>
<span class="fc" id="L1127">                                .collect(Collectors.toList());</span>
                    });

<span class="fc bfc" id="L1130" title="All 2 branches covered.">                    for(FieldAccessor property : propeties) {</span>
<span class="fc" id="L1131">                        Cell valueCell = cell;</span>
<span class="fc" id="L1132">                        final XlsColumn column = property.getAnnotationNullable(XlsColumn.class);</span>

                        //TODO: マージを考慮する必要はないかも
<span class="fc bfc" id="L1135" title="All 2 branches covered.">                        if(column.headerMerged() &gt; 0) {</span>
<span class="fc" id="L1136">                            hRow = hRow + column.headerMerged();</span>
<span class="fc" id="L1137">                            valueCell = POIUtils.getCell(sheet, hColumn, hRow);</span>
                        }

                        // for merged cell
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                        if(POIUtils.isEmptyCellContents(valueCell, config.getCellFormatter())) {</span>
<span class="fc bfc" id="L1142" title="All 4 branches covered.">                            if(column.merged() &amp;&amp; POIUtils.getBorderRight(valueCell).equals(BorderStyle.NONE)){</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">                                for(int k=hColumn-1; k &gt; hColumn; k--){</span>
<span class="nc" id="L1144">                                    Cell tmpCell = POIUtils.getCell(sheet, k, hRow);</span>
<span class="nc" id="L1145">                                    final CellStyle tmpCellFormat = tmpCell.getCellStyle();</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">                                    if(!POIUtils.getBorderLeft(tmpCell).equals(BorderStyle.NONE)){</span>
<span class="nc" id="L1147">                                        break;</span>
                                    }
<span class="nc bnc" id="L1149" title="All 2 branches missed.">                                    if(!POIUtils.isEmptyCellContents(tmpCell, config.getCellFormatter())){</span>
<span class="nc" id="L1150">                                        valueCell = tmpCell;</span>
<span class="nc" id="L1151">                                        break;</span>
                                    }
                                }
                            }
                        }

<span class="fc bfc" id="L1157" title="All 2 branches covered.">                        if(column.headerMerged() &gt; 0){</span>
<span class="fc" id="L1158">                            hRow = hRow - column.headerMerged();</span>
                        }

                        // 書き込む行が足りない場合の操作
<span class="fc bfc" id="L1162" title="All 2 branches covered.">                        if(emptyFlag) {</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">                            if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Break)) {</span>
<span class="fc" id="L1164">                                break;</span>

<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">                            } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Copy)) {</span>
                                // 1つ左のセルの書式をコピーする。
<span class="fc" id="L1168">                                final CellStyle style = POIUtils.getCell(sheet, valueCell.getColumnIndex()-1, valueCell.getRowIndex()).getCellStyle();</span>
<span class="fc" id="L1169">                                valueCell.setCellStyle(style);</span>
<span class="fc" id="L1170">                                valueCell.setCellType(CellType.BLANK);</span>

                                // セル幅の調整
<span class="fc" id="L1173">                                sheet.setColumnWidth(valueCell.getColumnIndex(), sheet.getColumnWidth(valueCell.getColumnIndex()-1));</span>

<span class="fc" id="L1175">                                recordOperation.incrementCopyRecord();</span>

<span class="pc bnc" id="L1177" title="All 2 branches missed.">                            } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Insert)) {</span>
                                // POIは列の追加をサポートしていないので非対応。
<span class="nc" id="L1179">                                throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L1180">                                        .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="nc" id="L1181">                                        .varWithAnno(&quot;anno&quot;, XlsRecordOption.class)</span>
<span class="nc" id="L1182">                                        .var(&quot;attrName&quot;, &quot;overCase&quot;)</span>
<span class="nc" id="L1183">                                        .varWithEnum(&quot;attrValue&quot;, OverOperation.Insert)</span>
<span class="nc" id="L1184">                                        .format());</span>
                            }

                        }

<span class="fc" id="L1189">                        valueCellPositions.add(CellPosition.of(valueCell));</span>

<span class="fc" id="L1191">                        recordOperation.setupCellPositoin(valueCell);</span>

<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">                        if(!Utils.isSaveCase(column.cases())) {</span>
<span class="nc" id="L1194">                            continue;</span>
                        }
                        // set for cell value
<span class="fc" id="L1197">                        property.setPosition(record, CellPosition.of(valueCell));</span>
<span class="fc" id="L1198">                        property.setLabel(record, headerInfo.getLabel());</span>
                        
<span class="fc" id="L1200">                        final Cell tempCommentCell = valueCell;</span>
<span class="fc" id="L1201">                        property.getCommentGetter().ifPresent(getter -&gt; config.getCommentOperator().saveCellComment(</span>
                                getter, tempCommentCell, record, accessor, config));

<span class="fc" id="L1204">                        final CellConverter converter = converterCache.computeIfAbsent(property.getName(), key -&gt; getCellConverter(property, config));</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">                        if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L1206">                            work.getErrors().registerFieldFormatter(property.getName(), property.getType(), (FieldFormatter&lt;?&gt;)converter, true);</span>
                        }

                        try {
<span class="fc" id="L1210">                            converter.toCell(property.getValue(record), record, sheet, CellPosition.of(valueCell));</span>
<span class="nc" id="L1211">                        } catch(TypeBindException e) {</span>
<span class="nc" id="L1212">                            work.addTypeBindError(e, valueCell, property.getName(), headerInfo.getLabel());</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                            if(!config.isContinueTypeBindFailure()) {</span>
<span class="nc" id="L1214">                                throw e;</span>
                            }
<span class="fc" id="L1216">                        }</span>

                        // セルをマージする
<span class="fc bfc" id="L1219" title="All 6 branches covered.">                        if(column.merged() &amp;&amp; (r &gt; 0) &amp;&amp; config.isMergeCellOnSave()) {</span>
<span class="fc" id="L1220">                            processSavingMergedCell(valueCell, sheet, mergedRanges, config);</span>
                        }
<span class="fc" id="L1222">                    }</span>
                }

                /*
                 * 残りの行の操作
                 *  行の追加やコピー処理をしていないときのみ実行する
                 */
<span class="pc bpc" id="L1229" title="1 of 6 branches missed.">                if(record == null &amp;&amp; emptyFlag == false &amp;&amp; recordOperation.isNotExecuteOverRecordOperation()) {</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">                    if(recordOperation.getAnnotation().remainedOperation().equals(RemainedOperation.None)) {</span>
                        // なにもしない

<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">                    } else if(recordOperation.getAnnotation().remainedOperation().equals(RemainedOperation.Clear)) {</span>
<span class="fc" id="L1234">                        Cell clearCell = POIUtils.getCell(sheet, hColumn, hRow);</span>
<span class="fc" id="L1235">                        clearCell.setCellType(CellType.BLANK);</span>

<span class="pc bnc" id="L1237" title="All 2 branches missed.">                    } else if(recordOperation.getAnnotation().remainedOperation().equals(RemainedOperation.Delete)) {</span>
                        // POIは列の削除をサポートしていないので非対応。
<span class="nc" id="L1239">                        throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L1240">                                .var(&quot;property&quot;, accessor.getNameWithClass())</span>
<span class="nc" id="L1241">                                .varWithAnno(&quot;anno&quot;, XlsRecordOption.class)</span>
<span class="nc" id="L1242">                                .var(&quot;attrName&quot;, &quot;remainedOperation&quot;)</span>
<span class="nc" id="L1243">                                .varWithEnum(&quot;attrValue&quot;, RemainedOperation.Delete)</span>
<span class="nc" id="L1244">                                .format());</span>
                    }
                }

            }

            // マップ形式のカラムを出力する
<span class="fc bfc" id="L1251" title="All 2 branches covered.">            if(record != null) {</span>
<span class="fc" id="L1252">                saveMapColumns(sheet, headers, valueCellPositions, CellPosition.of(initRow, hColumn), recordClass, record, terminal, anno, config, work, recordOperation);</span>

<span class="fc" id="L1254">                saveArrayColumns(sheet, headers, valueCellPositions, CellPosition.of(initRow, hColumn), recordClass, record, terminal, anno, config, work, recordOperation);</span>
            }

            // execute nested record.
<span class="fc" id="L1258">            int skipSize = 0;</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">            if(record != null) {</span>
<span class="fc" id="L1260">                skipSize = saveNestedRecords(sheet, headers, valueCellPositions, anno, CellPosition.of(initRow, hColumn), record,</span>
                        config, work, mergedRanges, recordOperation);
<span class="fc" id="L1262">                nestedRecordSize.addAndGet(skipSize);</span>
            }

<span class="fc bfc" id="L1265" title="All 2 branches covered.">            if(record != null) {</span>

                // set PostProcess listener
<span class="fc" id="L1268">                methodCache.getListenerClasses().forEach(listenerClass -&gt; {</span>
<span class="fc" id="L1269">                    listenerClass.getPostSaveMethods().forEach(method -&gt; {</span>
<span class="fc" id="L1270">                        work.addNeedPostProcess(new NeedProcess(record, listenerClass.getObject(), method));</span>
<span class="fc" id="L1271">                    });</span>
<span class="fc" id="L1272">                });</span>

                // set PostProcess method
<span class="fc" id="L1275">                methodCache.getPostSaveMethods().forEach(method -&gt; {</span>
<span class="fc" id="L1276">                    work.addNeedPostProcess(new NeedProcess(record, record, method));</span>
<span class="fc" id="L1277">                });</span>

            }

            // パスの位置の変更
<span class="fc" id="L1282">            work.getErrors().popNestedPath();</span>

<span class="fc bfc" id="L1284" title="All 2 branches covered.">            if(skipSize &gt; 0) {</span>
<span class="fc" id="L1285">                hColumn += skipSize;</span>
            } else {
<span class="fc" id="L1287">                hColumn++;</span>
            }

<span class="fc bfc" id="L1290" title="All 4 branches covered.">            if(emptyFlag == true &amp;&amp; (r &gt; result.size())) {</span>
                // セルが空で、書き込むデータがない場合。
<span class="fc" id="L1292">                break;</span>
            }
        }

<span class="fc" id="L1296">    }</span>

    /**
     * 表の見出しから、レコードのJavaクラスの定義にあるカラムの定義で初めて見つかるリストのインデックスを取得する。
     * ・カラムの定義とは、アノテーション「@XlsColumn」が付与されたもの。
     * @param headers 表の見出し情報。
     * @param recordClass アノテーション「@XlsColumn」が定義されたフィールドを持つレコード用のクラス。
     * @param annoReader AnnotationReader
     * @param config システム設定
     * @return 引数「headers」の該当する要素のインデックス番号。不明な場合は、0を返す。
     */
    private int getStartHeaderIndexForSaving(final List&lt;RecordHeader&gt; headers, Class&lt;?&gt; recordClass,
            final AnnotationReader annoReader, final Configuration config) {

        // レコードクラスが不明の場合、0を返す。
<span class="pc bpc" id="L1311" title="2 of 4 branches missed.">        if((recordClass == null || recordClass.equals(Object.class))) {</span>
<span class="nc" id="L1312">            return 0;</span>
        }

<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">        for(int i=0; i &lt; headers.size(); i++) {</span>
<span class="fc" id="L1316">            RecordHeader headerInfo = headers.get(i);</span>
<span class="fc" id="L1317">            final List&lt;FieldAccessor&gt; propeties = FieldAccessorUtils.getColumnPropertiesByName(</span>
<span class="fc" id="L1318">                    recordClass,annoReader, config,  headerInfo.getLabel())</span>
<span class="fc" id="L1319">                    .stream()</span>
<span class="fc" id="L1320">                    .filter(p -&gt; p.isWritable())</span>
<span class="fc" id="L1321">                    .collect(Collectors.toList());</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">            if(!propeties.isEmpty()) {</span>
<span class="fc" id="L1323">                return i;</span>
            }
        }

<span class="nc" id="L1327">        return 0;</span>

    }

    /**
     * 上部のセルと同じ値の場合マージする
     * @param currentCell
     * @param sheet
     * @param mergedRanges
     * @return
     */
    private boolean processSavingMergedCell(final Cell currentCell, final Sheet sheet,
            final List&lt;CellRangeAddress&gt; mergedRanges, final Configuration config) {

<span class="fc" id="L1341">        final int row = currentCell.getRowIndex();</span>
<span class="fc" id="L1342">        final int column = currentCell.getColumnIndex();</span>

<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">        if(column &lt;= 0) {</span>
<span class="nc" id="L1345">            return false;</span>
        }

        // 上のセルと比較する
<span class="fc" id="L1349">        final String value = POIUtils.getCellContents(currentCell, config.getCellFormatter());</span>
<span class="fc" id="L1350">        String upperValue = POIUtils.getCellContents(POIUtils.getCell(sheet, column-1, row), config.getCellFormatter());</span>

        // 結合されている場合、結合の先頭セルを取得する
<span class="fc" id="L1353">        int startColumn = column - 1;</span>
<span class="fc" id="L1354">        CellRangeAddress currentMergedRange = null;</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        for(CellRangeAddress range : mergedRanges) {</span>
            // 列が範囲外の場合
<span class="pc bpc" id="L1357" title="1 of 4 branches missed.">            if((range.getFirstColumn() &gt; startColumn) || (startColumn &gt; range.getLastColumn())) {</span>
<span class="fc" id="L1358">                continue;</span>
            }

            // 行が範囲外の場合
<span class="fc bfc" id="L1362" title="All 4 branches covered.">            if((range.getFirstRow() &gt; row) || (row &gt; range.getLastRow())) {</span>
<span class="fc" id="L1363">                continue;</span>
            }

<span class="fc" id="L1366">            upperValue = POIUtils.getCellContents(POIUtils.getCell(sheet, range.getFirstColumn(), row), config.getCellFormatter());</span>
<span class="fc" id="L1367">            currentMergedRange = range;</span>
<span class="fc" id="L1368">            break;</span>
        }

<span class="fc bfc" id="L1371" title="All 2 branches covered.">        if(!value.equals(upperValue)) {</span>
            // 値が異なる場合は結合しない
<span class="fc" id="L1373">            return false;</span>
        }

        // 既に結合済みの場合は一端解除する
<span class="fc bfc" id="L1377" title="All 2 branches covered.">        if(currentMergedRange != null) {</span>
<span class="fc" id="L1378">            startColumn = currentMergedRange.getFirstColumn();</span>
<span class="fc" id="L1379">            POIUtils.removeMergedRange(sheet, currentMergedRange);</span>
        }

<span class="fc" id="L1382">        final CellRangeAddress newRange = POIUtils.mergeCells(sheet, startColumn, row, column, row);</span>
<span class="fc" id="L1383">        mergedRanges.add(newRange);</span>
<span class="fc" id="L1384">        return true;</span>

    }

    private void saveMapColumns(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;CellPosition&gt; valueCellPositions,
            final CellPosition beginPosition, final Class&lt;?&gt; recordClass, final Object record, final RecordTerminal terminal,
            final XlsVerticalRecords anno, final Configuration config, final SavingWorkObject work,
            final RecordOperation recordOperation) throws XlsMapperException {

<span class="fc" id="L1393">        final List&lt;FieldAccessor&gt; properties = FieldAccessorUtils.getPropertiesWithAnnotation(</span>
<span class="fc" id="L1394">                recordClass, work.getAnnoReader(), XlsMapColumns.class)</span>
<span class="fc" id="L1395">                .stream()</span>
<span class="fc" id="L1396">                .filter(p -&gt; p.isReadable())</span>
<span class="fc" id="L1397">                .collect(Collectors.toList());</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">        for(FieldAccessor property : properties) {</span>

<span class="fc" id="L1400">            final XlsMapColumns mapAnno = property.getAnnotationNullable(XlsMapColumns.class);</span>

<span class="fc" id="L1402">            Class&lt;?&gt; valueClass = mapAnno.valueClass();</span>
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">            if(valueClass == Object.class) {</span>
<span class="fc" id="L1404">                valueClass = property.getComponentType();</span>
            }

            // get converter (map key class)
<span class="fc" id="L1408">            final CellConverter converter = getCellConverter(valueClass, property, config);</span>
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">            if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L1410">                work.getErrors().registerFieldFormatter(property.getName(), valueClass, (FieldFormatter&lt;?&gt;)converter, true);</span>
            }

<span class="fc" id="L1413">            boolean foundPreviousColumn = false;</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">            for(RecordHeader headerInfo : headers) {</span>
<span class="fc" id="L1415">                int hRow = beginPosition.getRow() + headerInfo.getInterval();</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                if(Utils.matches(headerInfo.getLabel(), mapAnno.previousColumnName(), config)){</span>
<span class="fc" id="L1417">                    foundPreviousColumn = true;</span>
<span class="fc" id="L1418">                    hRow++;</span>
<span class="fc" id="L1419">                    continue;</span>
                }

<span class="fc bfc" id="L1422" title="All 4 branches covered.">                if(Utils.isNotEmpty(mapAnno.nextColumnName()) &amp;&amp; Utils.matches(headerInfo.getLabel(), mapAnno.nextColumnName(), config)) {</span>
<span class="fc" id="L1423">                    break;</span>
                }

<span class="fc bfc" id="L1426" title="All 2 branches covered.">                if(foundPreviousColumn) {</span>
<span class="fc" id="L1427">                    final Cell cell = POIUtils.getCell(sheet, beginPosition.getColumn(), hRow);</span>

                    // 空セルか判断する
<span class="fc" id="L1430">                    boolean emptyFlag = true;</span>
<span class="pc bpc" id="L1431" title="1 of 2 branches missed.">                    if(terminal == RecordTerminal.Border) {</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">                        if(!POIUtils.getBorderTop(cell).equals(BorderStyle.NONE)) {</span>
<span class="fc" id="L1433">                            emptyFlag = false;</span>
                        } else {
<span class="fc" id="L1435">                            emptyFlag = true;</span>
                        }
                    }

<span class="fc bfc" id="L1439" title="All 2 branches covered.">                    if(!anno.terminateLabel().equals(&quot;&quot;)) {</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">                        if(Utils.matches(POIUtils.getCellContents(cell, config.getCellFormatter()), anno.terminateLabel(), config)) {</span>
<span class="nc" id="L1441">                            emptyFlag = true;</span>
                        }
                    }

                    // 空セルの場合
<span class="fc bfc" id="L1446" title="All 2 branches covered.">                    if(emptyFlag) {</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">                        if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Break)) {</span>
<span class="fc" id="L1448">                            break;</span>

<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">                        } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Copy)) {</span>
<span class="fc" id="L1451">                            final CellStyle style = POIUtils.getCell(sheet, cell.getColumnIndex()-1, cell.getRowIndex()).getCellStyle();</span>
<span class="fc" id="L1452">                            cell.setCellStyle(style);</span>
<span class="fc" id="L1453">                            cell.setCellType(CellType.BLANK);</span>

<span class="pc bnc" id="L1455" title="All 2 branches missed.">                        } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Insert)) {</span>
                            // POIは列の追加をサポートしていないので非対応。
<span class="nc" id="L1457">                            throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L1458">                                    .var(&quot;property&quot;, property.getNameWithClass())</span>
<span class="nc" id="L1459">                                    .varWithAnno(&quot;anno&quot;, XlsRecordOption.class)</span>
<span class="nc" id="L1460">                                    .var(&quot;attrName&quot;, &quot;overCase&quot;)</span>
<span class="nc" id="L1461">                                    .varWithEnum(&quot;attrValue&quot;, OverOperation.Insert)</span>
<span class="nc" id="L1462">                                    .format());</span>

                        }
                    }

<span class="fc" id="L1467">                    valueCellPositions.add(CellPosition.of(cell));</span>

<span class="fc" id="L1469">                    recordOperation.setupCellPositoin(cell);</span>

<span class="pc bpc" id="L1471" title="1 of 2 branches missed.">                    if(!Utils.isSaveCase(mapAnno.cases())) {</span>
<span class="nc" id="L1472">                        continue;</span>
                    }

                    // セルの値を出力する
<span class="fc" id="L1476">                    property.setMapPosition(record, CellPosition.of(cell), headerInfo.getLabel());</span>
<span class="fc" id="L1477">                    property.setMapLabel(record, headerInfo.getLabel(), headerInfo.getLabel());</span>
                    
<span class="fc" id="L1479">                    property.getMapCommentGetter().ifPresent(getter -&gt; config.getCommentOperator().saveMapCellComment(</span>
<span class="fc" id="L1480">                            getter, cell, record, headerInfo.getLabel(), property, config));</span>

                    try {
<span class="fc" id="L1483">                        Object value = property.getValueOfMap(headerInfo.getLabel(), record);</span>
<span class="fc" id="L1484">                        converter.toCell(value, record, sheet, CellPosition.of(cell));</span>
<span class="nc" id="L1485">                    } catch(TypeBindException e) {</span>
<span class="nc" id="L1486">                        work.addTypeBindError(e, cell, String.format(&quot;%s[%s]&quot;, property.getName(), headerInfo.getLabel()), headerInfo.getLabel());</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">                        if(!config.isContinueTypeBindFailure()) {</span>
<span class="nc" id="L1488">                            throw e;</span>
                        }
<span class="fc" id="L1490">                    }</span>
                }

<span class="fc" id="L1493">            }</span>
<span class="fc" id="L1494">        }</span>

<span class="fc" id="L1496">    }</span>

    private void saveArrayColumns(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;CellPosition&gt; valueCellPositions,
            final CellPosition beginPosition, Class&lt;?&gt; recordClass, Object record, RecordTerminal terminal,
            XlsVerticalRecords anno, Configuration config, SavingWorkObject work,
            RecordOperation recordOperation) throws XlsMapperException {


<span class="fc bfc" id="L1504" title="All 2 branches covered.">        for(RecordHeader headerInfo : headers) {</span>
<span class="fc" id="L1505">            int hRow = beginPosition.getRow() + headerInfo.getInterval();</span>

            // アノテーション「@XlsArrayColumns」の属性「columnName」と一致するプロパティを取得する。
<span class="fc" id="L1508">            final List&lt;FieldAccessor&gt; arrayProperties = FieldAccessorUtils.getArrayColumnsPropertiesByName(</span>
<span class="fc" id="L1509">                    recordClass, work.getAnnoReader(), config, headerInfo.getLabel())</span>
<span class="fc" id="L1510">                    .stream()</span>
<span class="fc" id="L1511">                    .filter(f -&gt; f.isReadable())</span>
<span class="fc" id="L1512">                    .collect(Collectors.toList());</span>

<span class="fc bfc" id="L1514" title="All 2 branches covered.">            if(arrayProperties.isEmpty()) {</span>
<span class="fc" id="L1515">                continue;</span>
            }

<span class="fc bfc" id="L1518" title="All 2 branches covered.">            for(FieldAccessor property : arrayProperties) {</span>

<span class="fc" id="L1520">                final XlsArrayColumns arrayAnno = property.getAnnotationNullable(XlsArrayColumns.class);</span>

<span class="fc" id="L1522">                Class&lt;?&gt; elementClass = arrayAnno.elementClass();</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">                if(elementClass == Object.class) {</span>
<span class="fc" id="L1524">                    elementClass = property.getComponentType();</span>
                }
<span class="fc" id="L1526">                final CellPosition initPosition = CellPosition.of(hRow, beginPosition.getColumn());</span>

                // 書き込む領域について、上のセルをコピーなどする。
<span class="fc" id="L1529">                int iRow = initPosition.getRow();</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                for(int i=0; i &lt; arrayAnno.size(); i++) {</span>
<span class="fc" id="L1531">                    final Cell cell = POIUtils.getCell(sheet, initPosition.getColumn(), iRow);</span>

                    // 空セルか判断する - 値のセルかどうか
<span class="fc" id="L1534">                    boolean emptyFlag = true;</span>

<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">                    if(terminal == RecordTerminal.Border) {</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">                        if(!POIUtils.getBorderTop(cell).equals(BorderStyle.NONE)) {</span>
<span class="fc" id="L1538">                            emptyFlag = false;</span>
                        } else {
<span class="fc" id="L1540">                            emptyFlag = true;</span>
                        }
                    }

<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">                    if(!anno.terminateLabel().equals(&quot;&quot;)) {</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                        if(Utils.matches(POIUtils.getCellContents(cell, config.getCellFormatter()), anno.terminateLabel(), config)) {</span>
<span class="nc" id="L1546">                            emptyFlag = true;</span>
                        }
                    }

                    // 空セルの場合
<span class="fc bfc" id="L1551" title="All 2 branches covered.">                    if(emptyFlag) {</span>
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">                        if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Break)) {</span>
<span class="nc" id="L1553">                            break;</span>

<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">                        } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Copy)) {</span>
<span class="fc" id="L1556">                            final Cell fromCell = POIUtils.getCell(sheet, cell.getColumnIndex()-1, cell.getRowIndex());</span>
<span class="fc" id="L1557">                            copyCellStyle(fromCell, cell);</span>

<span class="pc bnc" id="L1559" title="All 2 branches missed.">                        } else if(recordOperation.getAnnotation().overOperation().equals(OverOperation.Insert)) {</span>
                            // POIは列の追加をサポートしていないので非対応。
<span class="nc" id="L1561">                            throw new AnnotationInvalidException(anno, MessageBuilder.create(&quot;anno.attr.notSupportValue&quot;)</span>
<span class="nc" id="L1562">                                    .var(&quot;property&quot;, property.getNameWithClass())</span>
<span class="nc" id="L1563">                                    .varWithAnno(&quot;anno&quot;, XlsRecordOption.class)</span>
<span class="nc" id="L1564">                                    .var(&quot;attrName&quot;, &quot;overCase&quot;)</span>
<span class="nc" id="L1565">                                    .varWithEnum(&quot;attrValue&quot;, OverOperation.Insert)</span>
<span class="nc" id="L1566">                                    .format());</span>


                        }
                    }

                    // 結合情報を考慮して、インデックス（列番号）を次のセルに進める。
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">                    if(arrayAnno.elementMerged()) {</span>
<span class="fc" id="L1574">                        final CellRangeAddress mergedRegion = POIUtils.getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">                        if(mergedRegion != null) {</span>
<span class="fc" id="L1576">                            iRow += POIUtils.getRowSize(mergedRegion);</span>
                        } else {
<span class="fc" id="L1578">                            iRow++;</span>
                        }

<span class="fc" id="L1581">                    } else {</span>
<span class="nc" id="L1582">                        iRow++;</span>
                    }

<span class="fc" id="L1585">                    recordOperation.setupCellPositoin(cell);</span>
                }

<span class="pc bpc" id="L1588" title="1 of 2 branches missed.">                if(!Utils.isSaveCase(arrayAnno.cases())) {</span>
<span class="nc" id="L1589">                    continue;</span>
                }

                // get converter (component class)
<span class="fc" id="L1593">                final CellConverter&lt;?&gt; converter = getCellConverter(elementClass, property, config);</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">                if(converter instanceof FieldFormatter) {</span>
<span class="fc" id="L1595">                    work.getErrors().registerFieldFormatter(property.getName(), elementClass, (FieldFormatter&lt;?&gt;)converter, true);</span>
                }

<span class="fc" id="L1598">                ArrayCellsHandler arrayHandler = new ArrayCellsHandler(property, record, elementClass, sheet, config);</span>
<span class="fc" id="L1599">                arrayHandler.setLabel(headerInfo.getLabel());</span>

<span class="fc" id="L1601">                final Class&lt;?&gt; propertyType = property.getType();</span>
<span class="fc" id="L1602">                final Object result = property.getValue(record);</span>

<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">                if(result != null) {</span>
                    // インデックスが付いていないラベルの設定
<span class="fc" id="L1606">                    property.setLabel(record, headerInfo.getLabel());</span>
                }

<span class="pc bpc" id="L1609" title="1 of 2 branches missed.">                if(Collection.class.isAssignableFrom(propertyType)) {</span>

<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">                    final Collection&lt;Object&gt; value = (result == null ? new ArrayList&lt;Object&gt;() : (Collection&lt;Object&gt;) result);</span>
<span class="fc" id="L1612">                    final List&lt;Object&gt; list = Utils.convertCollectionToList(value);</span>
<span class="fc" id="L1613">                    arrayHandler.handleOnSaving(list, arrayAnno, initPosition, converter, work, ArrayDirection.Vertical);</span>

<span class="pc bnc" id="L1615" title="All 2 branches missed.">                } else if(propertyType.isArray()) {</span>

<span class="nc" id="L1617">                    final List&lt;Object&gt; list = Utils.asList(result, elementClass);</span>
<span class="nc" id="L1618">                    arrayHandler.handleOnSaving(list, arrayAnno, initPosition, converter, work, ArrayDirection.Vertical);</span>
                }

<span class="fc" id="L1621">            }</span>
<span class="fc" id="L1622">        }</span>

<span class="fc" id="L1624">    }</span>

    /**
     * セルの書式をコピーする。
     * &lt;p&gt;コピー先のセルの種類は、空セルとする。&lt;/p&gt;
     * &lt;p&gt;結合情報も列方向の結合をコピーする。&lt;/p&gt;
     *
     * @since 2.0
     * @param fromCell コピー元
     * @param toCell コピー先
     */
    private void copyCellStyle(final Cell fromCell, final Cell toCell) {

<span class="fc" id="L1637">        final CellStyle style = fromCell.getCellStyle();</span>
<span class="fc" id="L1638">        toCell.setCellStyle(style);</span>
<span class="fc" id="L1639">        toCell.setCellType(CellType.BLANK);</span>

        // 縦方向に結合されている場合、結合情報のコピーする。（XlsArrayColumns用）
<span class="fc" id="L1642">        final Sheet sheet = fromCell.getSheet();</span>
<span class="fc" id="L1643">        final CellRangeAddress mergedRegion = POIUtils.getMergedRegion(sheet, fromCell.getRowIndex(), fromCell.getColumnIndex());</span>
<span class="fc" id="L1644">        final int mergedSize = POIUtils.getRowSize(mergedRegion);</span>

<span class="fc bfc" id="L1646" title="All 2 branches covered.">        if(mergedSize &gt;= 2) {</span>
<span class="fc" id="L1647">            CellRangeAddress newMergedRegion = POIUtils.getMergedRegion(sheet, toCell.getRowIndex(), toCell.getColumnIndex());</span>
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">            if(newMergedRegion != null) {</span>
                // 既に結合している場合 - 通常はありえない。
<span class="nc" id="L1650">                return;</span>
            }

<span class="fc" id="L1653">            newMergedRegion = POIUtils.mergeCells(sheet,</span>
<span class="fc" id="L1654">                    toCell.getColumnIndex(), mergedRegion.getFirstRow(), toCell.getColumnIndex(), mergedRegion.getLastRow());</span>

            // 結合先のセルの書式も設定する
<span class="fc bfc" id="L1657" title="All 2 branches covered.">            for(int i=1; i &lt; mergedSize; i++) {</span>
<span class="fc" id="L1658">                Cell mergedFromCell = POIUtils.getCell(sheet, fromCell.getColumnIndex(), toCell.getRowIndex()+i);</span>

<span class="fc" id="L1660">                Cell mergedToCell = POIUtils.getCell(sheet, toCell.getColumnIndex(), toCell.getRowIndex()+i);</span>
<span class="fc" id="L1661">                mergedToCell.setCellStyle(mergedFromCell.getCellStyle());</span>
<span class="fc" id="L1662">                mergedToCell.setCellType(CellType.BLANK);</span>
            }
        }

<span class="fc" id="L1666">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private int saveNestedRecords(final Sheet sheet, final List&lt;RecordHeader&gt; headers, final List&lt;CellPosition&gt; valueCellPositions,
            final XlsVerticalRecords anno,
            final CellPosition beginPositoin,
            final Object record,
            final Configuration config, final SavingWorkObject work,
            final List&lt;CellRangeAddress&gt; mergedRanges, final RecordOperation recordOperation) throws XlsMapperException {

<span class="fc" id="L1676">        int skipSize = 0;</span>

<span class="fc" id="L1678">        final List&lt;FieldAccessor&gt; nestedProperties = FieldAccessorUtils.getPropertiesWithAnnotation(</span>
<span class="fc" id="L1679">                record.getClass(), work.getAnnoReader(), XlsNestedRecords.class)</span>
<span class="fc" id="L1680">                .stream()</span>
<span class="fc" id="L1681">                .filter(p -&gt; p.isReadable())</span>
<span class="fc" id="L1682">                .collect(Collectors.toList());</span>
        
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        for(FieldAccessor property : nestedProperties) {</span>

<span class="fc" id="L1686">            final XlsNestedRecords nestedAnno = property.getAnnotationNullable(XlsNestedRecords.class);</span>

<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">            if(!Utils.isSaveCase(nestedAnno.cases())) {</span>
<span class="nc" id="L1689">                continue;</span>
            }

<span class="fc" id="L1692">            final Class&lt;?&gt; clazz = property.getType();</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">            if(Collection.class.isAssignableFrom(clazz)) {</span>
                // mapping by one-to-many

<span class="fc" id="L1696">                Class&lt;?&gt; recordClass = nestedAnno.recordClass();</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L1698">                    recordClass = property.getComponentType();</span>
                }

<span class="fc" id="L1701">                Collection&lt;Object&gt; value = (Collection&lt;Object&gt;) property.getValue(record);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">                if(value == null) {</span>
                    // dummy empty record
<span class="fc" id="L1704">                    value = (Collection&lt;Object&gt;) Arrays.asList(config.createBean(recordClass));</span>
                }

<span class="fc" id="L1707">                final List&lt;Object&gt; list = Utils.convertCollectionToList(value);</span>
<span class="fc" id="L1708">                final AtomicInteger nestedRecordSize = new AtomicInteger(0);</span>
<span class="fc" id="L1709">                saveRecords(sheet, headers, anno, beginPositoin, nestedRecordSize, property, recordClass, list,</span>
                        config, work, mergedRanges, recordOperation);

<span class="pc bpc" id="L1712" title="1 of 2 branches missed.">                if(skipSize &lt; list.size()) {</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">                    if(nestedRecordSize.get() &gt; 0) {</span>
<span class="fc" id="L1714">                        skipSize = nestedRecordSize.get() - skipSize;</span>
                    } else {
<span class="fc" id="L1716">                        skipSize = list.size();</span>
                    }
                }

<span class="fc" id="L1720">                processSavingNestedMergedRecord(sheet, skipSize, valueCellPositions);</span>

<span class="fc bfc" id="L1722" title="All 2 branches covered.">            } else if(clazz.isArray()) {</span>

                // mapping by one-to-many

<span class="fc" id="L1726">                Class&lt;?&gt; recordClass = nestedAnno.recordClass();</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L1728">                    recordClass = property.getComponentType();</span>
                }

<span class="fc" id="L1731">                Object[] value = (Object[])property.getValue(record);</span>
<span class="fc bfc" id="L1732" title="All 2 branches covered.">                if(value == null) {</span>
                    // dummy empty record
<span class="fc" id="L1734">                    value = new Object[]{config.createBean(recordClass)};</span>
                }

<span class="fc" id="L1737">                final List&lt;Object&gt; list = Arrays.asList(value);</span>
<span class="fc" id="L1738">                final AtomicInteger nestedRecordSize = new AtomicInteger(0);</span>
<span class="fc" id="L1739">                saveRecords(sheet, headers, anno, beginPositoin, nestedRecordSize, property, recordClass, list,</span>
                        config, work, mergedRanges, recordOperation);

<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">                if(nestedRecordSize.get() &gt; 0) {</span>
<span class="nc" id="L1743">                    skipSize = nestedRecordSize.get() - skipSize;</span>
                } else {
<span class="fc" id="L1745">                    skipSize = list.size();</span>
                }

<span class="fc" id="L1748">                processSavingNestedMergedRecord(sheet, skipSize, valueCellPositions);</span>

<span class="fc" id="L1750">            } else {</span>

                // mapping by one-to-many
<span class="fc" id="L1753">                Class&lt;?&gt; recordClass = anno.recordClass();</span>
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">                if(recordClass == Object.class) {</span>
<span class="fc" id="L1755">                    recordClass = property.getType();</span>
                }

<span class="fc" id="L1758">                Object value = property.getValue(record);</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                if(value == null) {</span>
                    // dummy empty record
<span class="fc" id="L1761">                    value = config.createBean(recordClass);</span>
                }

<span class="fc" id="L1764">                List&lt;Object&gt; list = Arrays.asList(value);</span>
<span class="fc" id="L1765">                final AtomicInteger nestedRecordSize = new AtomicInteger(0);</span>
<span class="fc" id="L1766">                saveRecords(sheet, headers, anno, beginPositoin, nestedRecordSize, property, recordClass, list,</span>
                        config, work, mergedRanges, recordOperation);

<span class="pc bpc" id="L1769" title="1 of 2 branches missed.">                if(nestedRecordSize.get() &gt; 0) {</span>
<span class="nc" id="L1770">                    skipSize = nestedRecordSize.get() - skipSize;</span>
                } else {
<span class="fc" id="L1772">                    skipSize = list.size();</span>
                }

            }
<span class="fc" id="L1776">        }</span>

<span class="fc" id="L1778">        return skipSize;</span>
    }

    /**
     * ネストしたレコードの親のセルを結合する
     * @param sheet シート
     * @param mergedSize 結合するセルのサイズ
     * @param valueCellPositions 結合する開始位置のセルのアドレス
     */
    private void processSavingNestedMergedRecord(final Sheet sheet, final int mergedSize,
            final List&lt;CellPosition&gt; valueCellPositions) {

<span class="fc bfc" id="L1790" title="All 2 branches covered.">        if(mergedSize &lt;= 1) {</span>
<span class="fc" id="L1791">            return;</span>
        }

        // ネストした場合、上のセルのスタイルをコピーして、結合する
<span class="fc bfc" id="L1795" title="All 2 branches covered.">        for(CellPosition position : valueCellPositions) {</span>
<span class="fc" id="L1796">            Cell valueCell = POIUtils.getCell(sheet, position);</span>
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">            if(valueCell == null) {</span>
<span class="nc" id="L1798">                continue;</span>
            }

<span class="fc" id="L1801">            final CellStyle style = valueCell.getCellStyle();</span>

            // 結合するセルに対して、上のセルのスタイルをコピーする。
            // 列を挿入するときなどに必要になるため、スタイルを設定する。
<span class="fc bfc" id="L1805" title="All 2 branches covered.">            for(int i=1; i &lt; mergedSize; i++) {</span>
<span class="fc" id="L1806">                Cell mergedCell = POIUtils.getCell(sheet, position.getColumn() + i, position.getRow());</span>
<span class="fc" id="L1807">                mergedCell.setCellStyle(style);</span>
<span class="fc" id="L1808">                mergedCell.setCellType(CellType.BLANK);</span>
            }

<span class="fc" id="L1811">            final CellRangeAddress range = new CellRangeAddress(position.getRow(), position.getRow(),</span>
<span class="fc" id="L1812">                    position.getColumn(), position.getColumn() + mergedSize -1);</span>

            // 既に結合済みのセルがある場合、外す。
<span class="fc bfc" id="L1815" title="All 2 branches covered.">            for(int colIdx=range.getFirstColumn(); colIdx &lt;= range.getLastColumn(); colIdx++) {</span>
<span class="fc" id="L1816">                CellRangeAddress r = POIUtils.getMergedRegion(sheet, position.getRow(), colIdx);</span>
<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">                if(r != null) {</span>
<span class="nc" id="L1818">                    POIUtils.removeMergedRange(sheet, r);</span>
                }
            }

<span class="fc" id="L1822">            sheet.addMergedRegion(range);</span>
<span class="fc" id="L1823">        }</span>

<span class="fc" id="L1825">    }</span>

    /**
     * セルの入力規則の範囲を修正する。
     * @param sheet
     * @param recordOperation
     */
    private void correctDataValidation(final Sheet sheet, final RecordOperation recordOperation) {

<span class="fc bfc" id="L1834" title="All 2 branches covered.">        if(recordOperation.isNotExecuteRecordOperation()) {</span>
<span class="fc" id="L1835">            return;</span>
        }

        //TODO: セルの結合も考慮する

        // 操作をしていないセルの範囲の取得
<span class="fc" id="L1841">        final CellRangeAddress notOperateRange = new CellRangeAddress(</span>
<span class="fc" id="L1842">                recordOperation.getTopLeftPoisitoin().y,</span>
<span class="fc" id="L1843">                recordOperation.getBottomRightPosition().y,</span>
<span class="fc" id="L1844">                recordOperation.getTopLeftPoisitoin().x,</span>
<span class="fc" id="L1845">                recordOperation.getBottomRightPosition().x - recordOperation.getCountInsertRecord()</span>
                );

<span class="fc" id="L1848">        final List&lt;? extends DataValidation&gt; list = sheet.getDataValidations();</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        for(DataValidation validation : list) {</span>

<span class="fc" id="L1851">            final CellRangeAddressList region = validation.getRegions().copy();</span>
<span class="fc" id="L1852">            boolean changedRange = false;</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">            for(CellRangeAddress range : region.getCellRangeAddresses()) {</span>

<span class="fc bfc" id="L1855" title="All 2 branches covered.">                if(notOperateRange.isInRange(range.getFirstRow(), range.getFirstColumn())) {</span>
                    // 自身のセルの範囲の場合は、行の範囲を広げる
<span class="fc" id="L1857">                    range.setLastColumn(recordOperation.getBottomRightPosition().x);</span>
<span class="fc" id="L1858">                    changedRange = true;</span>

<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">                } else if(notOperateRange.getLastColumn() &lt; range.getFirstColumn()) {</span>
                    /*
                     * VerticalRecordsの場合は、挿入・削除はないので、自身以外の範囲は修正しない。
                     */
                }

            }

            // 修正した規則を、再度シートに追加する
<span class="fc bfc" id="L1869" title="All 2 branches covered.">            if(changedRange) {</span>
<span class="fc" id="L1870">                boolean updated = POIUtils.updateDataValidationRegion(sheet, validation.getRegions(), region);</span>
<span class="pc bpc" id="L1871" title="2 of 4 branches missed.">                assert updated == true;</span>
            }
<span class="fc" id="L1873">        }</span>

<span class="fc" id="L1875">    }</span>

    /**
     * 名前の定義の範囲を修正する。
     * @param sheet
     * @param recordOperation
     */
    private void correctNameRange(final Sheet sheet, final RecordOperation recordOperation) {

<span class="fc bfc" id="L1884" title="All 2 branches covered.">        if(recordOperation.isNotExecuteRecordOperation()) {</span>
<span class="fc" id="L1885">            return;</span>
        }

<span class="fc" id="L1888">        final Workbook workbook = sheet.getWorkbook();</span>
<span class="fc" id="L1889">        final int numName = workbook.getNumberOfNames();</span>
<span class="pc bpc" id="L1890" title="1 of 2 branches missed.">        if(numName == 0) {</span>
<span class="nc" id="L1891">            return;</span>
        }

        // 操作をしていないセルの範囲の取得
<span class="fc" id="L1895">        final CellRangeAddress notOperateRange = new CellRangeAddress(</span>
<span class="fc" id="L1896">                recordOperation.getTopLeftPoisitoin().y,</span>
<span class="fc" id="L1897">                recordOperation.getBottomRightPosition().y,</span>
<span class="fc" id="L1898">                recordOperation.getTopLeftPoisitoin().x,</span>
<span class="fc" id="L1899">                recordOperation.getBottomRightPosition().x - recordOperation.getCountInsertRecord()</span>
                );

<span class="fc bfc" id="L1902" title="All 2 branches covered.">        for(int i=0; i &lt; numName; i++) {</span>
<span class="fc" id="L1903">            final Name name = workbook.getNameAt(i);</span>

<span class="pc bpc" id="L1905" title="2 of 4 branches missed.">            if(name.isDeleted() || name.isFunctionName()) {</span>
                // 削除されている場合、関数の場合はスキップ
<span class="nc" id="L1907">                continue;</span>
            }

<span class="fc bfc" id="L1910" title="All 2 branches covered.">            if(!sheet.getSheetName().equals(name.getSheetName())) {</span>
                // 自身のシートでない名前は、修正しない。
<span class="fc" id="L1912">                continue;</span>
            }

<span class="fc" id="L1915">            AreaReference areaRef = new AreaReference(name.getRefersToFormula(), POIUtils.getVersion(sheet));</span>
<span class="fc" id="L1916">            CellReference firstCellRef = areaRef.getFirstCell();</span>
<span class="fc" id="L1917">            CellReference lastCellRef = areaRef.getLastCell();</span>

<span class="fc bfc" id="L1919" title="All 2 branches covered.">            if(notOperateRange.isInRange(firstCellRef.getRow(), firstCellRef.getCol())) {</span>
                // 自身のセルの範囲の場合は、行の範囲を広げる。

<span class="fc" id="L1922">                lastCellRef= new CellReference(</span>
<span class="fc" id="L1923">                        lastCellRef.getSheetName(),</span>
<span class="fc" id="L1924">                        lastCellRef.getRow(), recordOperation.getBottomRightPosition().x,</span>
<span class="fc" id="L1925">                        lastCellRef.isRowAbsolute(), lastCellRef.isColAbsolute());</span>
<span class="fc" id="L1926">                areaRef = new AreaReference(firstCellRef, lastCellRef, sheet.getWorkbook().getSpreadsheetVersion());</span>

                // 修正した範囲を再設定する
<span class="fc" id="L1929">                name.setRefersToFormula(areaRef.formatAsString());</span>

<span class="pc bpc" id="L1931" title="1 of 2 branches missed.">            } else if(notOperateRange.getLastColumn() &lt; firstCellRef.getCol()) {</span>
                /*
                 * 名前の定義の場合、自身のセルノ範囲より右方にあるセルの範囲の場合、
                 * 自動的に修正されるため、修正は必要なし。
                 */

            }

        }

<span class="fc" id="L1941">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>