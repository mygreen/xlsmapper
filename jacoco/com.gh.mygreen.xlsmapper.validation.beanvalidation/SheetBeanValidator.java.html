<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SheetBeanValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">XlsMapper</a> &gt; <a href="index.source.html" class="el_package">com.gh.mygreen.xlsmapper.validation.beanvalidation</a> &gt; <span class="el_source">SheetBeanValidator.java</span></div><h1>SheetBeanValidator.java</h1><pre class="source lang-java linenums">package com.gh.mygreen.xlsmapper.validation.beanvalidation;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Path;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.metadata.ConstraintDescriptor;

import org.hibernate.validator.internal.engine.path.PathImpl;

import com.gh.mygreen.xlsmapper.fieldaccessor.LabelGetterFactory;
import com.gh.mygreen.xlsmapper.fieldaccessor.PositionGetterFactory;
import com.gh.mygreen.xlsmapper.util.ArgUtils;
import com.gh.mygreen.xlsmapper.util.CellPosition;
import com.gh.mygreen.xlsmapper.util.Utils;
import com.gh.mygreen.xlsmapper.validation.FieldError;
import com.gh.mygreen.xlsmapper.validation.ObjectValidator;
import com.gh.mygreen.xlsmapper.validation.SheetBindingErrors;
import com.gh.mygreen.xlsmapper.validation.fieldvalidation.FieldFormatter;


/**
 * BeanValidaion JSR-303(ver.1.0)/JSR-349(ver.1.1)を利用したValidator.
 * 
 * @version 2.0
 * @author T.TSUCHIE
 *
 */
public class SheetBeanValidator implements ObjectValidator&lt;Object&gt; {
    
    /**
     * BeanValidationのアノテーションの属性で、メッセージ中の変数から除外するもの。
     * &lt;p&gt;メッセージの再構築を行う際に必要
     */
    private static final Set&lt;String&gt; EXCLUDE_MESSAGE_ANNOTATION_ATTRIBUTES;
    static {
<span class="fc" id="L45">        Set&lt;String&gt; set = new HashSet&lt;String&gt;(3);</span>
<span class="fc" id="L46">        set.add(&quot;message&quot;);</span>
<span class="fc" id="L47">        set.add(&quot;groups&quot;);</span>
<span class="fc" id="L48">        set.add(&quot;payload&quot;);</span>
        
<span class="fc" id="L50">        EXCLUDE_MESSAGE_ANNOTATION_ATTRIBUTES = Collections.unmodifiableSet(set);</span>
<span class="fc" id="L51">    }</span>
    
    private final Validator targetValidator;
    
<span class="fc" id="L55">    public SheetBeanValidator(final Validator targetValidator) {</span>
<span class="fc" id="L56">        ArgUtils.notNull(targetValidator, &quot;targetValidator&quot;);</span>
<span class="fc" id="L57">        this.targetValidator = targetValidator;</span>
<span class="fc" id="L58">    }</span>
    
<span class="nc" id="L60">    public SheetBeanValidator() {</span>
<span class="nc" id="L61">        this.targetValidator = createDefaultValidator();</span>
<span class="nc" id="L62">    }</span>
    
    /**
     * Bean Validatorのデフォルトのインスタンスを取得する。
     * @return
     */
    protected Validator createDefaultValidator() {
<span class="nc" id="L69">        final ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();</span>
<span class="nc" id="L70">        final Validator validator = validatorFactory.getValidator();</span>
<span class="nc" id="L71">        return validator;</span>
    }
    
    /**
     * BeanValidationのValidatorを取得する。
     * @return
     */
    public Validator getTargetValidator() {
<span class="fc" id="L79">        return targetValidator;</span>
    }
    
    /**
     * グループを指定して検証を実行する。
     * @param targetObj 検証対象のオブジェクト。
     * @param errors エラーオブジェクト
     * @param groups BeanValiationのグループのクラス
     */
    @Override
    public void validate(final Object targetObj, final SheetBindingErrors&lt;?&gt; errors, final Class&lt;?&gt;... groups) {
        
<span class="fc" id="L91">        ArgUtils.notNull(targetObj, &quot;targetObj&quot;);</span>
<span class="fc" id="L92">        ArgUtils.notNull(errors, &quot;errors&quot;);</span>
        
<span class="fc" id="L94">        processConstraintViolation(getTargetValidator().validate(targetObj, groups), errors);</span>
        
<span class="fc" id="L96">    }</span>
    
    /**
     * BeanValidationの検証結果をSheet用のエラーに変換する
     * @param violations BeanValidationの検証結果
     * @param errors シートのエラー
     */
    protected void processConstraintViolation(final Set&lt;ConstraintViolation&lt;Object&gt;&gt; violations,
            final SheetBindingErrors&lt;?&gt; errors) {
        
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for(ConstraintViolation&lt;Object&gt; violation : violations) {</span>
            
<span class="fc" id="L108">            final String fieldName = violation.getPropertyPath().toString();</span>
<span class="fc" id="L109">            final Optional&lt;FieldError&gt; fieldError = errors.getFirstFieldError(fieldName);</span>
            
<span class="pc bpc" id="L111" title="3 of 4 branches missed.">            if(fieldError.isPresent() &amp;&amp; fieldError.get().isConversionFailure()) {</span>
                // 型変換エラーが既存のエラーにある場合は、処理をスキップする。
<span class="nc" id="L113">                continue;</span>
            }
            
<span class="fc" id="L116">            final ConstraintDescriptor&lt;?&gt; cd = violation.getConstraintDescriptor();</span>
            
            /*
             * エラーメッセージのコードは、後から再変換できるよう、BeanValidationの形式のエラーコードも付けておく。
             */
<span class="fc" id="L121">            final String[] errorCodes = new String[]{</span>
<span class="fc" id="L122">                    cd.getAnnotation().annotationType().getSimpleName(),</span>
<span class="fc" id="L123">                    cd.getAnnotation().annotationType().getCanonicalName(),</span>
<span class="fc" id="L124">                    cd.getAnnotation().annotationType().getCanonicalName() + &quot;.message&quot;</span>
                    };
            
<span class="fc" id="L127">            final Map&lt;String, Object&gt; errorVars = createVariableForConstraint(cd);</span>
            
<span class="fc" id="L129">            final String nestedPath = errors.buildFieldPath(fieldName);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            if(Utils.isEmpty(nestedPath)) {</span>
                // オブジェクトエラーの場合
<span class="nc" id="L132">                errors.createGlobalError(errorCodes)</span>
<span class="nc" id="L133">                    .variables(errorVars)</span>
<span class="nc" id="L134">                    .defaultMessage(violation.getMessage())</span>
<span class="nc" id="L135">                    .buildAndAddError();</span>
                
            } else {
                // フィールドエラーの場合
                
                // 親のオブジェクトから、セルの座標を取得する
<span class="fc" id="L141">                final Object parentObj = violation.getLeafBean();</span>
<span class="fc" id="L142">                final Path path = violation.getPropertyPath();</span>
<span class="fc" id="L143">                Optional&lt;CellPosition&gt; cellAddress = Optional.empty();</span>
<span class="fc" id="L144">                Optional&lt;String&gt; label = Optional.empty();</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                if(path instanceof PathImpl) {</span>
<span class="fc" id="L146">                    final PathImpl pathImpl = (PathImpl) path;</span>
<span class="fc" id="L147">                    cellAddress = new PositionGetterFactory().create(parentObj.getClass(), pathImpl.getLeafNode().getName())</span>
<span class="fc" id="L148">                            .map(getter -&gt; getter.get(parentObj)).orElse(Optional.empty());</span>
                    
<span class="fc" id="L150">                    label = new LabelGetterFactory().create(parentObj.getClass(), pathImpl.getLeafNode().getName())</span>
<span class="fc" id="L151">                            .map(getter -&gt; getter.get(parentObj)).orElse(Optional.empty());</span>
                    
                }
                
                // フィールドフォーマッタ
<span class="fc" id="L156">                Class&lt;?&gt; fieldType = errors.getFieldType(nestedPath);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">                if(fieldType != null) {</span>
<span class="fc" id="L158">                    FieldFormatter&lt;?&gt; fieldFormatter = errors.findFieldFormatter(nestedPath, fieldType);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                    if(fieldFormatter != null) {</span>
<span class="fc" id="L160">                        errorVars.putIfAbsent(&quot;fieldFormatter&quot;, fieldFormatter);</span>
                    }
                }
                
                // 実際の値を取得する
<span class="fc" id="L165">                errorVars.putIfAbsent(&quot;validatedValue&quot;, violation.getInvalidValue());</span>
                
<span class="fc" id="L167">                errors.createFieldError(fieldName, errorCodes)</span>
<span class="fc" id="L168">                    .variables(errorVars)</span>
<span class="fc" id="L169">                    .address(cellAddress)</span>
<span class="fc" id="L170">                    .label(label)</span>
<span class="fc" id="L171">                    .defaultMessage(violation.getMessage())</span>
<span class="fc" id="L172">                    .buildAndAddError();</span>
                
            }
            
<span class="fc" id="L176">        }</span>
        
<span class="fc" id="L178">    }</span>
    
    /**
     * BeanValidationのアノテーションの値を元に、メッセージ変数を作成する。
     * @param descriptor
     * @return メッセージ変数
     */
    protected Map&lt;String, Object&gt; createVariableForConstraint(final ConstraintDescriptor&lt;?&gt; descriptor) {
        
<span class="fc" id="L187">        final Map&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();</span>
        
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for(Map.Entry&lt;String, Object&gt; entry : descriptor.getAttributes().entrySet()) {</span>
<span class="fc" id="L190">            final String attrName = entry.getKey();</span>
<span class="fc" id="L191">            final Object attrValue = entry.getValue();</span>
            
            // メッセージ変数で必要ないものを除外する
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if(EXCLUDE_MESSAGE_ANNOTATION_ATTRIBUTES.contains(attrName)) {</span>
<span class="fc" id="L195">                continue;</span>
            }
            
<span class="fc" id="L198">            vars.put(attrName, attrValue);</span>
<span class="fc" id="L199">        }</span>
        
<span class="fc" id="L201">        return vars;</span>
        
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>